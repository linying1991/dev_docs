var search_data = {"index":{"searchIndex":["dsl","object","ripper","filter","add_event()","check_arity()","column()","const_missing()","filename()","generate_eventids1()","generate_eventids2_table()","grammar()","lex()","lineno()","main()","method_missing()","new()","new()","new_var()","opt_event()","parse()","parse()","prelude()","read_ids1()","read_ids1_with_locations()","read_ids2()","sexp()","sexp_raw()","slice()","state()","strip_locations()","tokenize()","usage()","usercode()"],"longSearchIndex":["dsl","object","ripper","ripper::filter","object#add_event()","object#check_arity()","ripper::filter#column()","object::const_missing()","ripper::filter#filename()","object#generate_eventids1()","object#generate_eventids2_table()","object#grammar()","ripper::lex()","ripper::filter#lineno()","object#main()","object#method_missing()","dsl::new()","ripper::filter::new()","object#new_var()","object#opt_event()","ripper::parse()","ripper::filter#parse()","object#prelude()","object#read_ids1()","object#read_ids1_with_locations()","object#read_ids2()","ripper::sexp()","ripper::sexp_raw()","ripper::slice()","ripper::filter#state()","object#strip_locations()","ripper::tokenize()","object#usage()","object#usercode()"],"info":[["DSL","","DSL.html","","<p>Simple DSL implementation for Ripper code generation\n<p>input:   % ripper: stmts_add(stmts_new, void_stmt …\n"],["Object","","Object.html","",""],["Ripper","","Ripper.html","","<p>Ripper is a Ruby script parser.\n<p>You can get information from the parser with event-based style. Information\n…\n"],["Ripper::Filter","","Ripper/Filter.html","","<p>This class handles only scanner events, which are dispatched in the ‘right’\norder (same with input). …\n"],["add_event","Object","Object.html#method-i-add_event","(event, args, qundef_check = false)",""],["check_arity","Object","Object.html#method-i-check_arity","(h)",""],["column","Ripper::Filter","Ripper/Filter.html#method-i-column","()","<p>The column number of the current token. This value starts from 0. This\nmethod is valid only in event …\n"],["const_missing","Object","Object.html#method-c-const_missing","(name)",""],["filename","Ripper::Filter","Ripper/Filter.html#method-i-filename","()","<p>The file name of the input.\n"],["generate_eventids1","Object","Object.html#method-i-generate_eventids1","(ids)",""],["generate_eventids2_table","Object","Object.html#method-i-generate_eventids2_table","(ids)",""],["grammar","Object","Object.html#method-i-grammar","(f, out)",""],["lex","Ripper","Ripper.html#method-c-lex","(src, filename = '-', lineno = 1)","<p>Tokenizes the Ruby program and returns an array of an array, which is\nformatted like <code>[[lineno, column],</code> …\n"],["lineno","Ripper::Filter","Ripper/Filter.html#method-i-lineno","()","<p>The line number of the current token. This value starts from 1. This method\nis valid only in event handlers. …\n"],["main","Object","Object.html#method-i-main","()",""],["method_missing","Object","Object.html#method-i-method_missing","(event, *args)",""],["new","DSL","DSL.html#method-c-new","(code, options)",""],["new","Ripper::Filter","Ripper/Filter.html#method-c-new","(src, filename = '-', lineno = 1)","<p>Creates a new Ripper::Filter instance, passes parameters <code>src</code>,\n<code>filename</code>, and <code>lineno</code> to Ripper::Lexer.new …\n"],["new_var","Object","Object.html#method-i-new_var","()",""],["opt_event","Object","Object.html#method-i-opt_event","(event, default, addend)",""],["parse","Ripper","Ripper.html#method-c-parse","(src, filename = '(ripper)', lineno = 1)","<p>Parses the given Ruby program read from <code>src</code>. <code>src</code>\nmust be a String or an IO or a object with a #gets method. …\n"],["parse","Ripper::Filter","Ripper/Filter.html#method-i-parse","(init = nil)","<p>Starts the parser. <code>init</code> is a data accumulator and is passed to\nthe next event handler (as of Enumerable#inject …\n"],["prelude","Object","Object.html#method-i-prelude","(f, out)",""],["read_ids1","Object","Object.html#method-i-read_ids1","(path)",""],["read_ids1_with_locations","Object","Object.html#method-i-read_ids1_with_locations","(path)",""],["read_ids2","Object","Object.html#method-i-read_ids2","(path)",""],["sexp","Ripper","Ripper.html#method-c-sexp","(src, filename = '-', lineno = 1)","<p>EXPERIMENTAL &mdash; Parses <code>src</code> and create S-exp tree. Returns more readable tree\nrather than Ripper.sexp_raw …\n"],["sexp_raw","Ripper","Ripper.html#method-c-sexp_raw","(src, filename = '-', lineno = 1)","<p>EXPERIMENTAL &mdash; Parses <code>src</code> and create S-exp tree. This method is mainly for\ndeveloper use.\n\n<pre>require 'ripper' ...</pre>\n\n"],["slice","Ripper","Ripper.html#method-c-slice","(src, pattern, n = 0)","<p>EXPERIMENTAL &mdash; Parses <code>src</code> and return a string which was matched to\n<code>pattern</code>. <code>pattern</code> should be described …\n"],["state","Ripper::Filter","Ripper/Filter.html#method-i-state","()","<p>The scanner’s state of the current token. This value is the bitwise OR of\nzero or more of the <code>Ripper::EXPR_*</code> …\n"],["strip_locations","Object","Object.html#method-i-strip_locations","(h)",""],["tokenize","Ripper","Ripper.html#method-c-tokenize","(src, filename = '-', lineno = 1)","<p>Tokenizes the Ruby program and returns an array of strings.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">p</span> <span class=\"ruby-constant\">Ripper</span>.<span class=\"ruby-identifier\">tokenize</span>(<span class=\"ruby-string\">&quot;def m(a) nil end&quot;</span>)\n   <span class=\"ruby-comment\"># ...</span>\n</pre>\n"],["usage","Object","Object.html#method-i-usage","(msg)",""],["usercode","Object","Object.html#method-i-usercode","(f, out)",""]]}}