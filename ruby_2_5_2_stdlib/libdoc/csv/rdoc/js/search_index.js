var search_data = {"index":{"searchIndex":["csv","deletesuffix","fieldsconverter","malformedcsverror","matchp","parser","inputsscanner","invalidencoding","scanner","unoptimizedstringio","row","table","writer","object","<<()","<<()","<<()","<<()","==()","==()","csv()","[]()","[]()","[]=()","[]=()","add_converter()","add_row()","binmode?()","by_col()","by_col!()","by_col_or_row()","by_col_or_row!()","by_row()","by_row!()","col_sep()","column_separator()","convert()","convert()","converters()","delete()","delete()","delete_if()","delete_if()","delete_suffix()","dig()","dig()","each()","each()","each()","each()","each_line()","each_line()","each_line()","each_pair()","empty?()","eof()","eof?()","eof?()","eos?()","fetch()","field()","field?()","field_row?()","field_size_limit()","field_size_limit()","fields()","filter()","flock()","force_quotes?()","foreach()","generate()","generate_line()","gets()","gets()","has_key?()","header?()","header_convert()","header_converters()","header_row?()","header_row?()","header_row?()","headers()","headers()","headers()","headers()","include?()","index()","initialize_copy()","inspect()","inspect()","inspect()","instance()","ioctl()","keep_back()","keep_back()","keep_drop()","keep_drop()","keep_end()","keep_end()","keep_start()","keep_start()","key?()","liberal_parsing?()","liberal_parsing?()","line()","line()","lineno()","lineno()","match?()","member?()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","open()","parse()","parse()","parse_line()","path()","push()","push()","puts()","quote_char()","quote_character()","read()","read()","readline()","readlines()","readlines()","rest()","return_headers?()","return_headers?()","rewind()","rewind()","row_sep()","row_separator()","scan()","scan_all()","shift()","skip_blanks?()","skip_blanks?()","skip_lines()","skip_lines()","stat()","table()","to_a()","to_csv()","to_csv()","to_h()","to_hash()","to_i()","to_io()","to_s()","to_s()","unconverted_fields?()","unconverted_fields?()","use_headers?()","values_at()","values_at()","write_headers?()"],"longSearchIndex":["csv","csv::deletesuffix","csv::fieldsconverter","csv::malformedcsverror","csv::matchp","csv::parser","csv::parser::inputsscanner","csv::parser::invalidencoding","csv::parser::scanner","csv::parser::unoptimizedstringio","csv::row","csv::table","csv::writer","object","csv#<<()","csv::row#<<()","csv::table#<<()","csv::writer#<<()","csv::row#==()","csv::table#==()","object#csv()","csv::row#[]()","csv::table#[]()","csv::row#[]=()","csv::table#[]=()","csv::fieldsconverter#add_converter()","csv#add_row()","csv#binmode?()","csv::table#by_col()","csv::table#by_col!()","csv::table#by_col_or_row()","csv::table#by_col_or_row!()","csv::table#by_row()","csv::table#by_row!()","csv#col_sep()","csv::parser#column_separator()","csv#convert()","csv::fieldsconverter#convert()","csv#converters()","csv::row#delete()","csv::table#delete()","csv::row#delete_if()","csv::table#delete_if()","csv::deletesuffix#delete_suffix()","csv::row#dig()","csv::table#dig()","csv#each()","csv::fieldsconverter#each()","csv::row#each()","csv::table#each()","csv::parser::inputsscanner#each_line()","csv::parser::scanner#each_line()","csv::parser::unoptimizedstringio#each_line()","csv::row#each_pair()","csv::fieldsconverter#empty?()","csv#eof()","csv#eof?()","csv::parser::unoptimizedstringio#eof?()","csv::parser::inputsscanner#eos?()","csv::row#fetch()","csv::row#field()","csv::row#field?()","csv::row#field_row?()","csv#field_size_limit()","csv::parser#field_size_limit()","csv::row#fields()","csv::filter()","csv#flock()","csv#force_quotes?()","csv::foreach()","csv::generate()","csv::generate_line()","csv#gets()","csv::parser::unoptimizedstringio#gets()","csv::row#has_key?()","csv::row#header?()","csv#header_convert()","csv#header_converters()","csv#header_row?()","csv::parser#header_row?()","csv::row#header_row?()","csv#headers()","csv::parser#headers()","csv::row#headers()","csv::table#headers()","csv::row#include?()","csv::row#index()","csv::row#initialize_copy()","csv#inspect()","csv::row#inspect()","csv::table#inspect()","csv::instance()","csv#ioctl()","csv::parser::inputsscanner#keep_back()","csv::parser::scanner#keep_back()","csv::parser::inputsscanner#keep_drop()","csv::parser::scanner#keep_drop()","csv::parser::inputsscanner#keep_end()","csv::parser::scanner#keep_end()","csv::parser::inputsscanner#keep_start()","csv::parser::scanner#keep_start()","csv::row#key?()","csv#liberal_parsing?()","csv::parser#liberal_parsing?()","csv#line()","csv::parser#line()","csv#lineno()","csv::parser#lineno()","csv::matchp#match?()","csv::row#member?()","csv::new()","csv::fieldsconverter::new()","csv::malformedcsverror::new()","csv::parser::new()","csv::parser::inputsscanner::new()","csv::parser::scanner::new()","csv::parser::unoptimizedstringio::new()","csv::row::new()","csv::table::new()","csv::writer::new()","csv::open()","csv::parse()","csv::parser#parse()","csv::parse_line()","csv#path()","csv::row#push()","csv::table#push()","csv#puts()","csv#quote_char()","csv::parser#quote_character()","csv::read()","csv#read()","csv#readline()","csv#readlines()","csv::readlines()","csv::parser::inputsscanner#rest()","csv#return_headers?()","csv::parser#return_headers?()","csv#rewind()","csv::writer#rewind()","csv#row_sep()","csv::parser#row_separator()","csv::parser::inputsscanner#scan()","csv::parser::inputsscanner#scan_all()","csv#shift()","csv#skip_blanks?()","csv::parser#skip_blanks?()","csv#skip_lines()","csv::parser#skip_lines()","csv#stat()","csv::table()","csv::table#to_a()","csv::row#to_csv()","csv::table#to_csv()","csv::row#to_h()","csv::row#to_hash()","csv#to_i()","csv#to_io()","csv::row#to_s()","csv::table#to_s()","csv#unconverted_fields?()","csv::parser#unconverted_fields?()","csv::parser#use_headers?()","csv::row#values_at()","csv::table#values_at()","csv#write_headers?()"],"info":[["CSV","","CSV.html","","<p>This class provides a complete interface to CSV files and data. It offers\ntools to enable you to read …\n"],["CSV::DeleteSuffix","","CSV/DeleteSuffix.html","",""],["CSV::FieldsConverter","","CSV/FieldsConverter.html","","<p>Note: Don’t use this class directly. This is an internal class.\n"],["CSV::MalformedCSVError","","CSV/MalformedCSVError.html","","<p>The error thrown when the parser encounters illegal CSV formatting.\n"],["CSV::MatchP","","CSV/MatchP.html","",""],["CSV::Parser","","CSV/Parser.html","","<p>Note: Don’t use this class directly. This is an internal class.\n"],["CSV::Parser::InputsScanner","","CSV/Parser/InputsScanner.html","","<p>CSV::InputsScanner receives IO inputs, encoding and the chunk_size. It also\ncontrols the life cycle of …\n"],["CSV::Parser::InvalidEncoding","","CSV/Parser/InvalidEncoding.html","","<p>Raised when encoding is invalid.\n"],["CSV::Parser::Scanner","","CSV/Parser/Scanner.html","","<p>CSV::Scanner receives a CSV output, scans it and return the content. It\nalso controls the life cycle …\n"],["CSV::Parser::UnoptimizedStringIO","","CSV/Parser/UnoptimizedStringIO.html","",""],["CSV::Row","","CSV/Row.html","","<p>A CSV::Row is part Array and part Hash. It retains an order for the fields\nand allows duplicates just …\n"],["CSV::Table","","CSV/Table.html","","<p>A CSV::Table is a two-dimensional data structure for representing CSV\ndocuments. Tables allow you to …\n"],["CSV::Writer","","CSV/Writer.html","","<p>Note: Don’t use this class directly. This is an internal class.\n"],["Object","","Object.html","",""],["<<","CSV","CSV.html#method-i-3C-3C","(row)","<p>The primary write method for wrapped Strings and IOs, <code>row</code> (an\nArray or CSV::Row) is converted to CSV …\n"],["<<","CSV::Row","CSV/Row.html#method-i-3C-3C","(arg)","<p>If a two-element Array is provided, it is assumed to be a header and field\nand the pair is appended. …\n"],["<<","CSV::Table","CSV/Table.html#method-i-3C-3C","(row_or_array)","<p>Adds a new row to the bottom end of this table. You can provide an Array,\nwhich will be converted to …\n"],["<<","CSV::Writer","CSV/Writer.html#method-i-3C-3C","(row)","<p>Adds a new row\n"],["==","CSV::Row","CSV/Row.html#method-i-3D-3D","(other)","<p>Returns <code>true</code> if this row contains the same headers and fields\nin the same order as <code>other</code>.\n"],["==","CSV::Table","CSV/Table.html#method-i-3D-3D","(other)","<p>Returns <code>true</code> if all rows of this table ==()\n<code>other</code>‘s rows.\n"],["CSV","Object","Object.html#method-i-CSV","(*args, &block)","<p>Passes <code>args</code> to CSV::instance.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">CSV</span>(<span class=\"ruby-string\">&quot;CSV,data&quot;</span>).<span class=\"ruby-identifier\">read</span>\n  <span class=\"ruby-comment\">#=&gt; [[&quot;CSV&quot;, &quot;data&quot;]]</span>\n</pre>\n<p>If a block is given, the instance …\n"],["[]","CSV::Row","CSV/Row.html#method-i-5B-5D","(header_or_index, minimum_index = 0)",""],["[]","CSV::Table","CSV/Table.html#method-i-5B-5D","(index_or_header)","<p>In the default mixed mode, this method returns rows for index access and\ncolumns for header access.  …\n"],["[]=","CSV::Row","CSV/Row.html#method-i-5B-5D-3D","(*args)","<p>Looks up the field by the semantics described in CSV::Row.field() and\nassigns the <code>value</code>.\n<p>Assigning past …\n"],["[]=","CSV::Table","CSV/Table.html#method-i-5B-5D-3D","(index_or_header, value)","<p>In the default mixed mode, this method assigns rows for index access and\ncolumns for header access.  …\n"],["add_converter","CSV::FieldsConverter","CSV/FieldsConverter.html#method-i-add_converter","(name=nil, &converter)",""],["add_row","CSV","CSV.html#method-i-add_row","(row)",""],["binmode?","CSV","CSV.html#method-i-binmode-3F","()",""],["by_col","CSV::Table","CSV/Table.html#method-i-by_col","()","<p>Returns a duplicate table object, in column mode. This is handy for\nchaining in a single call without …\n"],["by_col!","CSV::Table","CSV/Table.html#method-i-by_col-21","()","<p>Switches the mode of this table to column mode. All calls to indexing and\niteration methods will work …\n"],["by_col_or_row","CSV::Table","CSV/Table.html#method-i-by_col_or_row","()","<p>Returns a duplicate table object, in mixed mode. This is handy for chaining\nin a single call without …\n"],["by_col_or_row!","CSV::Table","CSV/Table.html#method-i-by_col_or_row-21","()","<p>Switches the mode of this table to mixed mode. All calls to indexing and\niteration methods will use the …\n"],["by_row","CSV::Table","CSV/Table.html#method-i-by_row","()","<p>Returns a duplicate table object, in row mode.  This is handy for chaining\nin a single call without changing …\n"],["by_row!","CSV::Table","CSV/Table.html#method-i-by_row-21","()","<p>Switches the mode of this table to row mode. All calls to indexing and\niteration methods will work with …\n"],["col_sep","CSV","CSV.html#method-i-col_sep","()","<p>The encoded <code>:col_sep</code> used in parsing and writing. See CSV::new\nfor details.\n"],["column_separator","CSV::Parser","CSV/Parser.html#method-i-column_separator","()",""],["convert","CSV","CSV.html#method-i-convert","(name = nil, &converter)","<p>You can use this method to install a CSV::Converters built-in, or provide a\nblock that handles a custom …\n"],["convert","CSV::FieldsConverter","CSV/FieldsConverter.html#method-i-convert","(fields, headers, lineno)",""],["converters","CSV","CSV.html#method-i-converters","()","<p>Returns the current list of converters in effect. See CSV::new for details.\nBuilt-in converters will …\n"],["delete","CSV::Row","CSV/Row.html#method-i-delete","(header_or_index, minimum_index = 0)","<p>Removes a pair from the row by <code>header</code> or <code>index</code>.\nThe pair is located as described in CSV::Row.field() …\n"],["delete","CSV::Table","CSV/Table.html#method-i-delete","(*indexes_or_headers)","<p>Removes and returns the indicated columns or rows. In the default mixed\nmode indices refer to rows and …\n"],["delete_if","CSV::Row","CSV/Row.html#method-i-delete_if","(&block)","<p>The provided <code>block</code> is passed a header and field for each pair\nin the row and expected to return <code>true</code> …\n"],["delete_if","CSV::Table","CSV/Table.html#method-i-delete_if","(&block)","<p>Removes any column or row for which the block returns <code>true</code>. In\nthe default mixed mode or row mode, iteration …\n"],["delete_suffix","CSV::DeleteSuffix","CSV/DeleteSuffix.html#method-i-delete_suffix","(suffix)",""],["dig","CSV::Row","CSV/Row.html#method-i-dig","(index_or_header, *indexes)","<p>Extracts the nested value specified by the sequence of <code>index</code>\nor <code>header</code> objects by calling dig at each …\n"],["dig","CSV::Table","CSV/Table.html#method-i-dig","(index_or_header, *index_or_headers)","<p>Extracts the nested value specified by the sequence of <code>index</code>\nor <code>header</code> objects by calling dig at each …\n"],["each","CSV","CSV.html#method-i-each","(&block)","<p>Yields each row of the data source in turn.\n<p>Support for Enumerable.\n<p>The data source must be open for reading. …\n"],["each","CSV::FieldsConverter","CSV/FieldsConverter.html#method-i-each","(&block)",""],["each","CSV::Row","CSV/Row.html#method-i-each","(&block)","<p>Yields each pair of the row as header and field tuples (much like iterating\nover a Hash). This method …\n"],["each","CSV::Table","CSV/Table.html#method-i-each","(&block)","<p>In the default mixed mode or row mode, iteration is the standard row major\nwalking of rows. In column …\n"],["each_line","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-each_line","(row_separator)",""],["each_line","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-i-each_line","(row_separator)",""],["each_line","CSV::Parser::UnoptimizedStringIO","CSV/Parser/UnoptimizedStringIO.html#method-i-each_line","(*args, &block)",""],["each_pair","CSV::Row","CSV/Row.html#method-i-each_pair","(&block)",""],["empty?","CSV::FieldsConverter","CSV/FieldsConverter.html#method-i-empty-3F","()",""],["eof","CSV","CSV.html#method-i-eof","()",""],["eof?","CSV","CSV.html#method-i-eof-3F","()",""],["eof?","CSV::Parser::UnoptimizedStringIO","CSV/Parser/UnoptimizedStringIO.html#method-i-eof-3F","()",""],["eos?","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-eos-3F","()",""],["fetch","CSV::Row","CSV/Row.html#method-i-fetch","(header, *varargs)","<p>This method will fetch the field value by <code>header</code>. It has the\nsame behavior as Hash#fetch: if there is …\n"],["field","CSV::Row","CSV/Row.html#method-i-field","(header_or_index, minimum_index = 0)","<p>This method will return the field value by <code>header</code> or\n<code>index</code>. If a field is not found, <code>nil</code> is returned.\n…\n"],["field?","CSV::Row","CSV/Row.html#method-i-field-3F","(data)","<p>Returns <code>true</code> if <code>data</code> matches a field in this row,\nand <code>false</code> otherwise.\n"],["field_row?","CSV::Row","CSV/Row.html#method-i-field_row-3F","()","<p>Returns <code>true</code> if this is a field row.\n"],["field_size_limit","CSV","CSV.html#method-i-field_size_limit","()","<p>The limit for field size, if any. See CSV::new for details.\n"],["field_size_limit","CSV::Parser","CSV/Parser.html#method-i-field_size_limit","()",""],["fields","CSV::Row","CSV/Row.html#method-i-fields","(*headers_and_or_indices)","<p>This method accepts any number of arguments which can be headers, indices,\nRanges of either, or two-element …\n"],["filter","CSV","CSV.html#method-c-filter","(input=nil, output=nil, **options)","<p>This method is a convenience for building Unix-like filters for CSV data.\nEach row is yielded to the …\n"],["flock","CSV","CSV.html#method-i-flock","(*args)",""],["force_quotes?","CSV","CSV.html#method-i-force_quotes-3F","()","<p>Returns <code>true</code> if all output fields are quoted. See CSV::new for\ndetails.\n"],["foreach","CSV","CSV.html#method-c-foreach","(path, mode=\"r\", **options, &block)","<p>This method is intended as the primary interface for reading CSV files. You\npass a <code>path</code> and any <code>options</code> …\n"],["generate","CSV","CSV.html#method-c-generate","(str=nil, **options)","<p>This method wraps a String you provide, or an empty default String, in a\nCSV object which is passed to …\n"],["generate_line","CSV","CSV.html#method-c-generate_line","(row, **options)","<p>This method is a shortcut for converting a single row (Array) into a CSV\nString.\n<p>The <code>options</code> parameter …\n"],["gets","CSV","CSV.html#method-i-gets","()",""],["gets","CSV::Parser::UnoptimizedStringIO","CSV/Parser/UnoptimizedStringIO.html#method-i-gets","(*args)",""],["has_key?","CSV::Row","CSV/Row.html#method-i-has_key-3F","(header)","<p>Returns <code>true</code> if there is a field with the given\n<code>header</code>.\n"],["header?","CSV::Row","CSV/Row.html#method-i-header-3F","(header)",""],["header_convert","CSV","CSV.html#method-i-header_convert","(name = nil, &converter)","<p>Identical to CSV#convert(), but for header rows.\n<p>Note that this method must be called before header rows …\n"],["header_converters","CSV","CSV.html#method-i-header_converters","()","<p>Returns the current list of converters in effect for headers. See CSV::new\nfor details. Built-in converters …\n"],["header_row?","CSV","CSV.html#method-i-header_row-3F","()","<p>Returns <code>true</code> if the next row read will be a header row.\n"],["header_row?","CSV::Parser","CSV/Parser.html#method-i-header_row-3F","()",""],["header_row?","CSV::Row","CSV/Row.html#method-i-header_row-3F","()","<p>Returns <code>true</code> if this is a header row.\n"],["headers","CSV","CSV.html#method-i-headers","()","<p>Returns <code>nil</code> if headers will not be used, <code>true</code> if\nthey will but have not yet been read, or the actual …\n"],["headers","CSV::Parser","CSV/Parser.html#method-i-headers","()",""],["headers","CSV::Row","CSV/Row.html#method-i-headers","()","<p>Returns the headers of this row.\n"],["headers","CSV::Table","CSV/Table.html#method-i-headers","()","<p>Returns the headers for the first row of this table (assumed to match all\nother rows). The headers Array …\n"],["include?","CSV::Row","CSV/Row.html#method-i-include-3F","(header)",""],["index","CSV::Row","CSV/Row.html#method-i-index","(header, minimum_index = 0)","<p>This method will return the index of a field with the provided\n<code>header</code>. The <code>offset</code> can be used to locate …\n"],["initialize_copy","CSV::Row","CSV/Row.html#method-i-initialize_copy","(other)",""],["inspect","CSV","CSV.html#method-i-inspect","()","<p>Returns a simplified description of the key CSV attributes in an ASCII\ncompatible String.\n"],["inspect","CSV::Row","CSV/Row.html#method-i-inspect","()","<p>A summary of fields, by header, in an ASCII compatible String.\n"],["inspect","CSV::Table","CSV/Table.html#method-i-inspect","()","<p>Shows the mode and size of this table in a US-ASCII String.\n"],["instance","CSV","CSV.html#method-c-instance","(data = $stdout, **options)","<p>This method will return a CSV instance, just like CSV::new(), but the\ninstance will be cached and returned …\n"],["ioctl","CSV","CSV.html#method-i-ioctl","(*args)",""],["keep_back","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-keep_back","()",""],["keep_back","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-i-keep_back","()",""],["keep_drop","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-keep_drop","()",""],["keep_drop","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-i-keep_drop","()",""],["keep_end","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-keep_end","()",""],["keep_end","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-i-keep_end","()",""],["keep_start","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-keep_start","()",""],["keep_start","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-i-keep_start","()",""],["key?","CSV::Row","CSV/Row.html#method-i-key-3F","(header)",""],["liberal_parsing?","CSV","CSV.html#method-i-liberal_parsing-3F","()","<p>Returns <code>true</code> if illegal input is handled. See CSV::new for\ndetails.\n"],["liberal_parsing?","CSV::Parser","CSV/Parser.html#method-i-liberal_parsing-3F","()",""],["line","CSV","CSV.html#method-i-line","()","<p>The last row read from this file.\n"],["line","CSV::Parser","CSV/Parser.html#method-i-line","()",""],["lineno","CSV","CSV.html#method-i-lineno","()","<p>The line number of the last row read from this file. Fields with nested\nline-end characters will not …\n"],["lineno","CSV::Parser","CSV/Parser.html#method-i-lineno","()",""],["match?","CSV::MatchP","CSV/MatchP.html#method-i-match-3F","(pattern)",""],["member?","CSV::Row","CSV/Row.html#method-i-member-3F","(header)",""],["new","CSV","CSV.html#method-c-new","(data, col_sep: \",\", row_sep: :auto, quote_char: '\"', field_size_limit: nil, converters: nil, unconverted_fields: nil, headers: false, return_headers: false, write_headers: nil, header_converters: nil, skip_blanks: false, force_quotes: false, skip_lines: nil, liberal_parsing: false, internal_encoding: nil, external_encoding: nil, encoding: nil, nil_value: nil, empty_value: \"\", quote_empty: true, write_converters: nil, write_nil_value: nil, write_empty_value: \"\", strip: false)","<p>This constructor will wrap either a String or IO object passed in\n<code>data</code> for reading and/or writing. In …\n"],["new","CSV::FieldsConverter","CSV/FieldsConverter.html#method-c-new","(options={})","<p>A CSV::FieldsConverter is a data structure for storing the fields converter\nproperties to be passed as …\n"],["new","CSV::MalformedCSVError","CSV/MalformedCSVError.html#method-c-new","(message, line_number)",""],["new","CSV::Parser","CSV/Parser.html#method-c-new","(input, options)",""],["new","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-c-new","(inputs, encoding, chunk_size: 8192)",""],["new","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-c-new","(*args)",""],["new","CSV::Parser::UnoptimizedStringIO","CSV/Parser/UnoptimizedStringIO.html#method-c-new","(string)",""],["new","CSV::Row","CSV/Row.html#method-c-new","(headers, fields, header_row = false)","<p>Constructs a new CSV::Row from <code>headers</code> and\n<code>fields</code>, which are expected to be Arrays. If one Array is\nshorter …\n"],["new","CSV::Table","CSV/Table.html#method-c-new","(array_of_rows, headers: nil)","<p>Constructs a new CSV::Table from <code>array_of_rows</code>, which are\nexpected to be CSV::Row objects. All rows are …\n"],["new","CSV::Writer","CSV/Writer.html#method-c-new","(output, options)",""],["open","CSV","CSV.html#method-c-open","(filename, mode=\"r\", **options)","<p>This method opens an IO object, and wraps that with CSV. This is intended\nas the primary interface for …\n"],["parse","CSV","CSV.html#method-c-parse","(str, **options, &block)","<p>This method can be used to easily parse CSV out of a String. You may either\nprovide a <code>block</code> which will …\n"],["parse","CSV::Parser","CSV/Parser.html#method-i-parse","(&block)",""],["parse_line","CSV","CSV.html#method-c-parse_line","(line, **options)","<p>This method is a shortcut for converting a single line of a CSV String into\nan Array. Note that if <code>line</code> …\n"],["path","CSV","CSV.html#method-i-path","()",""],["push","CSV::Row","CSV/Row.html#method-i-push","(*args)","<p>A shortcut for appending multiple fields. Equivalent to:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">args</span>.<span class=\"ruby-identifier\">each</span> { <span class=\"ruby-operator\">|</span><span class=\"ruby-identifier\">arg</span><span class=\"ruby-operator\">|</span> <span class=\"ruby-identifier\">csv_row</span> <span class=\"ruby-operator\">&lt;&lt;</span> <span class=\"ruby-identifier\">arg</span> }\n</pre>\n<p>This method …\n"],["push","CSV::Table","CSV/Table.html#method-i-push","(*rows)","<p>A shortcut for appending multiple rows. Equivalent to:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">rows</span>.<span class=\"ruby-identifier\">each</span> { <span class=\"ruby-operator\">|</span><span class=\"ruby-identifier\">row</span><span class=\"ruby-operator\">|</span> <span class=\"ruby-keyword\">self</span> <span class=\"ruby-operator\">&lt;&lt;</span> <span class=\"ruby-identifier\">row</span> }\n</pre>\n<p>This method returns …\n"],["puts","CSV","CSV.html#method-i-puts","(row)",""],["quote_char","CSV","CSV.html#method-i-quote_char","()","<p>The encoded <code>:quote_char</code> used in parsing and writing. See\nCSV::new for details.\n"],["quote_character","CSV::Parser","CSV/Parser.html#method-i-quote_character","()",""],["read","CSV","CSV.html#method-c-read","(path, **options)","<p>Use to slurp a CSV file into an Array of Arrays. Pass the <code>path</code>\nto the file and any <code>options</code> CSV::new() …\n"],["read","CSV","CSV.html#method-i-read","()","<p>Slurps the remaining rows and returns an Array of Arrays.\n<p>The data source must be open for reading.\n"],["readline","CSV","CSV.html#method-i-readline","()",""],["readlines","CSV","CSV.html#method-i-readlines","()",""],["readlines","CSV","CSV.html#method-c-readlines","(path, **options)","<p>Alias for CSV::read().\n"],["rest","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-rest","()",""],["return_headers?","CSV","CSV.html#method-i-return_headers-3F","()","<p>Returns <code>true</code> if headers will be returned as a row of results.\nSee CSV::new for details.\n"],["return_headers?","CSV::Parser","CSV/Parser.html#method-i-return_headers-3F","()",""],["rewind","CSV","CSV.html#method-i-rewind","()","<p>Rewinds the underlying IO object and resets CSV’s lineno() counter.\n"],["rewind","CSV::Writer","CSV/Writer.html#method-i-rewind","()","<p>Winds back to the beginning\n"],["row_sep","CSV","CSV.html#method-i-row_sep","()","<p>The encoded <code>:row_sep</code> used in parsing and writing. See CSV::new\nfor details.\n"],["row_separator","CSV::Parser","CSV/Parser.html#method-i-row_separator","()",""],["scan","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-scan","(pattern)",""],["scan_all","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-scan_all","(pattern)",""],["shift","CSV","CSV.html#method-i-shift","()","<p>The primary read method for wrapped Strings and IOs, a single row is pulled\nfrom the data source, parsed …\n"],["skip_blanks?","CSV","CSV.html#method-i-skip_blanks-3F","()","<p>Returns <code>true</code> blank lines are skipped by the parser. See\nCSV::new for details.\n"],["skip_blanks?","CSV::Parser","CSV/Parser.html#method-i-skip_blanks-3F","()",""],["skip_lines","CSV","CSV.html#method-i-skip_lines","()","<p>The regex marking a line as a comment. See CSV::new for details.\n"],["skip_lines","CSV::Parser","CSV/Parser.html#method-i-skip_lines","()",""],["stat","CSV","CSV.html#method-i-stat","(*args)",""],["table","CSV","CSV.html#method-c-table","(path, **options)","<p>A shortcut for:\n\n<pre>CSV.read( path, { headers:           true,\n                  converters:        :numeric, ...</pre>\n"],["to_a","CSV::Table","CSV/Table.html#method-i-to_a","()","<p>Returns the table as an Array of Arrays. Headers will be the first row,\nthen all of the field rows will …\n"],["to_csv","CSV::Row","CSV/Row.html#method-i-to_csv","(**options)","<p>Returns the row as a CSV String. Headers are not used. Equivalent to:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">csv_row</span>.<span class=\"ruby-identifier\">fields</span>.<span class=\"ruby-identifier\">to_csv</span>( <span class=\"ruby-identifier\">options</span> )\n</pre>\n"],["to_csv","CSV::Table","CSV/Table.html#method-i-to_csv","(write_headers: true, **options)","<p>Returns the table as a complete CSV String. Headers will be listed first,\nthen all of the field rows. …\n"],["to_h","CSV::Row","CSV/Row.html#method-i-to_h","()","<p>Collapses the row into a simple Hash. Be warned that this discards field\norder and clobbers duplicate …\n"],["to_hash","CSV::Row","CSV/Row.html#method-i-to_hash","()",""],["to_i","CSV","CSV.html#method-i-to_i","()",""],["to_io","CSV","CSV.html#method-i-to_io","()",""],["to_s","CSV::Row","CSV/Row.html#method-i-to_s","(**options)",""],["to_s","CSV::Table","CSV/Table.html#method-i-to_s","(write_headers: true, **options)",""],["unconverted_fields?","CSV","CSV.html#method-i-unconverted_fields-3F","()","<p>Returns <code>true</code> if unconverted_fields() to parsed results. See\nCSV::new for details.\n"],["unconverted_fields?","CSV::Parser","CSV/Parser.html#method-i-unconverted_fields-3F","()",""],["use_headers?","CSV::Parser","CSV/Parser.html#method-i-use_headers-3F","()",""],["values_at","CSV::Row","CSV/Row.html#method-i-values_at","(*headers_and_or_indices)",""],["values_at","CSV::Table","CSV/Table.html#method-i-values_at","(*indices_or_headers)","<p>The mixed mode default is to treat a list of indices as row access,\nreturning the rows indicated. Anything …\n"],["write_headers?","CSV","CSV.html#method-i-write_headers-3F","()","<p>Returns <code>true</code> if headers are written in output. See CSV::new\nfor details.\n"]]}}