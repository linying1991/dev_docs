var search_data = {"index":{"searchIndex":["kernel","pp","ppmethods","rubyvm","abstractsyntaxtree","node","check_inspect_key()","comma_breakable()","guard_inspect_key()","object_address_group()","object_group()","pop_inspect_key()","pp()","pp()","pp()","pp()","pp_hash()","pp_object()","pretty_inspect()","pretty_print()","pretty_print_children()","push_inspect_key()","seplist()","sharing_detection()","sharing_detection=()","singleline_pp()","width_for()"],"longSearchIndex":["kernel","pp","pp::ppmethods","rubyvm","rubyvm::abstractsyntaxtree","rubyvm::abstractsyntaxtree::node","pp::ppmethods#check_inspect_key()","pp::ppmethods#comma_breakable()","pp::ppmethods#guard_inspect_key()","pp::ppmethods#object_address_group()","pp::ppmethods#object_group()","pp::ppmethods#pop_inspect_key()","kernel#pp()","kernel::pp()","pp::pp()","pp::ppmethods#pp()","pp::ppmethods#pp_hash()","pp::ppmethods#pp_object()","kernel#pretty_inspect()","rubyvm::abstractsyntaxtree::node#pretty_print()","rubyvm::abstractsyntaxtree::node#pretty_print_children()","pp::ppmethods#push_inspect_key()","pp::ppmethods#seplist()","pp::sharing_detection()","pp::sharing_detection=()","pp::singleline_pp()","pp::width_for()"],"info":[["Kernel","","Kernel.html","",""],["PP","","PP.html","","<p>A pretty-printer for Ruby objects.\n<p>What PP Does\n<p>Standard output by #p returns this:\n"],["PP::PPMethods","","PP/PPMethods.html","",""],["RubyVM","","RubyVM.html","",""],["RubyVM::AbstractSyntaxTree","","RubyVM/AbstractSyntaxTree.html","",""],["RubyVM::AbstractSyntaxTree::Node","","RubyVM/AbstractSyntaxTree/Node.html","",""],["check_inspect_key","PP::PPMethods","PP/PPMethods.html#method-i-check_inspect_key","(id)","<p>Check whether the object_id <code>id</code> is in the current buffer of objects to be pretty printed. Used to break …\n"],["comma_breakable","PP::PPMethods","PP/PPMethods.html#method-i-comma_breakable","()","<p>A convenience method which is same as follows:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">text</span> <span class=\"ruby-string\">&#39;,&#39;</span>\n<span class=\"ruby-identifier\">breakable</span>\n</pre>\n"],["guard_inspect_key","PP::PPMethods","PP/PPMethods.html#method-i-guard_inspect_key","()","<p>Yields to a block and preserves the previous set of objects being printed.\n"],["object_address_group","PP::PPMethods","PP/PPMethods.html#method-i-object_address_group","(obj, &block)","<p>A convenience method, like object_group, but also reformats the Object’s object_id.\n"],["object_group","PP::PPMethods","PP/PPMethods.html#method-i-object_group","(obj)","<p>A convenience method which is same as follows:\n\n<pre>group(1, &#39;#&lt;&#39; + obj.class.name, &#39;&gt;&#39;) { ... }</pre>\n"],["pop_inspect_key","PP::PPMethods","PP/PPMethods.html#method-i-pop_inspect_key","(id)","<p>Removes an object from the set of objects being pretty printed.\n"],["pp","Kernel","Kernel.html#method-i-pp","(*objs)","<p>prints arguments in pretty form.\n<p>pp returns argument(s).\n"],["pp","Kernel","Kernel.html#method-c-pp","(*objs)","<p>prints arguments in pretty form.\n<p>pp returns argument(s).\n"],["pp","PP","PP.html#method-c-pp","(obj, out=$>, width=width_for(out))","<p>Outputs <code>obj</code> to <code>out</code> in pretty printed format of <code>width</code> columns in width.\n<p>If <code>out</code> is omitted, <code>$&gt;</code> is assumed. …\n"],["pp","PP::PPMethods","PP/PPMethods.html#method-i-pp","(obj)","<p>Adds <code>obj</code> to the pretty printing buffer using Object#pretty_print or Object#pretty_print_cycle.\n<p>Object#pretty_print_cycle …\n"],["pp_hash","PP::PPMethods","PP/PPMethods.html#method-i-pp_hash","(obj)","<p>A pretty print for a Hash\n"],["pp_object","PP::PPMethods","PP/PPMethods.html#method-i-pp_object","(obj)","<p>A present standard failsafe for pretty printing any given Object\n"],["pretty_inspect","Kernel","Kernel.html#method-i-pretty_inspect","()","<p>Returns a pretty printed object as a string.\n<p>In order to use this method you must first require the PP …\n"],["pretty_print","RubyVM::AbstractSyntaxTree::Node","RubyVM/AbstractSyntaxTree/Node.html#method-i-pretty_print","(q)",""],["pretty_print_children","RubyVM::AbstractSyntaxTree::Node","RubyVM/AbstractSyntaxTree/Node.html#method-i-pretty_print_children","(q, names = [])",""],["push_inspect_key","PP::PPMethods","PP/PPMethods.html#method-i-push_inspect_key","(id)","<p>Adds the object_id <code>id</code> to the set of objects being pretty printed, so as to not repeat objects.\n"],["seplist","PP::PPMethods","PP/PPMethods.html#method-i-seplist","(list, sep=nil, iter_method=:each)","<p>Adds a separated list. The list is separated by comma with breakable space, by default.\n<p>#seplist iterates …\n"],["sharing_detection","PP","PP.html#method-c-sharing_detection","()","<p>Returns the sharing detection flag as a boolean value. It is false (nil) by default.\n"],["sharing_detection=","PP","PP.html#method-c-sharing_detection-3D","(b)","<p>Sets the sharing detection flag to b.\n"],["singleline_pp","PP","PP.html#method-c-singleline_pp","(obj, out=$>)","<p>Outputs <code>obj</code> to <code>out</code> like PP.pp but with no indent and newline.\n<p>PP.singleline_pp returns <code>out</code>.\n"],["width_for","PP","PP.html#method-c-width_for","(out)","<p>Returns the usable width for <code>out</code>. As the width of <code>out</code>:\n<p>If <code>out</code> is assigned to a tty device, its width is …\n"]]}}