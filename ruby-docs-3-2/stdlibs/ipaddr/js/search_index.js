var search_data = {"index":{"searchIndex":["ipaddr","addressfamilyerror","error","invalidaddresserror","invalidprefixerror","ipsocket","socket","&()","<<()","<=>()","==()","===()",">>()","_ipv4_compat?()","_reverse()","_to_string()","addr_mask()","coerce_other()","eql?()","getaddress()","getaddress_orig()","hash()","hton()","in6_addr()","in_addr()","include?()","inspect()","ip6_arpa()","ip6_int()","ipv4?()","ipv4_compat()","ipv4_compat?()","ipv4_mapped()","ipv4_mapped?()","ipv6?()","link_local?()","loopback?()","mask()","mask!()","native()","netmask()","new()","new_ntoh()","ntop()","prefix()","prefix=()","private?()","reverse()","set()","succ()","to_i()","to_range()","to_s()","to_string()","valid_v6?()","zone_id()","zone_id=()","|()","~()"],"longSearchIndex":["ipaddr","ipaddr::addressfamilyerror","ipaddr::error","ipaddr::invalidaddresserror","ipaddr::invalidprefixerror","ipsocket","socket","ipaddr#&()","ipaddr#<<()","ipaddr#<=>()","ipaddr#==()","ipaddr#===()","ipaddr#>>()","ipaddr#_ipv4_compat?()","ipaddr#_reverse()","ipaddr#_to_string()","ipaddr#addr_mask()","ipaddr#coerce_other()","ipaddr#eql?()","ipsocket::getaddress()","ipsocket::getaddress_orig()","ipaddr#hash()","ipaddr#hton()","ipaddr#in6_addr()","ipaddr#in_addr()","ipaddr#include?()","ipaddr#inspect()","ipaddr#ip6_arpa()","ipaddr#ip6_int()","ipaddr#ipv4?()","ipaddr#ipv4_compat()","ipaddr#ipv4_compat?()","ipaddr#ipv4_mapped()","ipaddr#ipv4_mapped?()","ipaddr#ipv6?()","ipaddr#link_local?()","ipaddr#loopback?()","ipaddr#mask()","ipaddr#mask!()","ipaddr#native()","ipaddr#netmask()","ipaddr::new()","ipaddr::new_ntoh()","ipaddr::ntop()","ipaddr#prefix()","ipaddr#prefix=()","ipaddr#private?()","ipaddr#reverse()","ipaddr#set()","ipaddr#succ()","ipaddr#to_i()","ipaddr#to_range()","ipaddr#to_s()","ipaddr#to_string()","ipsocket::valid_v6?()","ipaddr#zone_id()","ipaddr#zone_id=()","ipaddr#|()","ipaddr#~()"],"info":[["IPAddr","","IPAddr.html","","<p>IPAddr provides a set of methods to manipulate an IP address.  Both IPv4 and IPv6 are supported.\n<p>Example …\n"],["IPAddr::AddressFamilyError","","IPAddr/AddressFamilyError.html","","<p>Raised when the address family is invalid such as an address with an unsupported family, an address with …\n"],["IPAddr::Error","","IPAddr/Error.html","","<p>Generic IPAddr related error. Exceptions raised in this class should inherit from Error.\n"],["IPAddr::InvalidAddressError","","IPAddr/InvalidAddressError.html","","<p>Raised when the provided IP address is an invalid address.\n"],["IPAddr::InvalidPrefixError","","IPAddr/InvalidPrefixError.html","","<p>Raised when the address is an invalid length.\n"],["IPSocket","","IPSocket.html","",""],["Socket","","Socket.html","",""],["&","IPAddr","IPAddr.html#method-i-26","(other)","<p>Returns a new ipaddr built by bitwise AND.\n"],["<<","IPAddr","IPAddr.html#method-i-3C-3C","(num)","<p>Returns a new ipaddr built by bitwise left shift.\n"],["<=>","IPAddr","IPAddr.html#method-i-3C-3D-3E","(other)","<p>Compares the ipaddr with another.\n"],["==","IPAddr","IPAddr.html#method-i-3D-3D","(other)","<p>Returns true if two ipaddrs are equal.\n"],["===","IPAddr","IPAddr.html#method-i-3D-3D-3D","(other)",""],[">>","IPAddr","IPAddr.html#method-i-3E-3E","(num)","<p>Returns a new ipaddr built by bitwise right-shift.\n"],["_ipv4_compat?","IPAddr","IPAddr.html#method-i-_ipv4_compat-3F","()",""],["_reverse","IPAddr","IPAddr.html#method-i-_reverse","()",""],["_to_string","IPAddr","IPAddr.html#method-i-_to_string","(addr)",""],["addr_mask","IPAddr","IPAddr.html#method-i-addr_mask","(addr)",""],["coerce_other","IPAddr","IPAddr.html#method-i-coerce_other","(other)",""],["eql?","IPAddr","IPAddr.html#method-i-eql-3F","(other)","<p>Checks equality used by Hash.\n"],["getaddress","IPSocket","IPSocket.html#method-c-getaddress","(s)","<p>Returns a <code>String</code> based representation of a valid DNS hostname, IPv4 or IPv6 address.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">IPSocket</span>.<span class=\"ruby-identifier\">getaddress</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["getaddress_orig","IPSocket","IPSocket.html#method-c-getaddress_orig","(s)",""],["hash","IPAddr","IPAddr.html#method-i-hash","()","<p>Returns a hash value used by Hash, Set, and Array classes\n"],["hton","IPAddr","IPAddr.html#method-i-hton","()","<p>Returns a network byte ordered string form of the IP address.\n"],["in6_addr","IPAddr","IPAddr.html#method-i-in6_addr","(left)",""],["in_addr","IPAddr","IPAddr.html#method-i-in_addr","(addr)",""],["include?","IPAddr","IPAddr.html#method-i-include-3F","(other)","<p>Returns true if the given ipaddr is in the range.\n<p>e.g.:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;ipaddr&#39;</span>\n<span class=\"ruby-identifier\">net1</span> = <span class=\"ruby-constant\">IPAddr</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&quot;192.168.2.0/24&quot;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["inspect","IPAddr","IPAddr.html#method-i-inspect","()","<p>Returns a string containing a human-readable representation of the ipaddr. (“#&lt;IPAddr: family:address/mask&gt;”) …\n"],["ip6_arpa","IPAddr","IPAddr.html#method-i-ip6_arpa","()","<p>Returns a string for DNS reverse lookup compatible with RFC3172.\n"],["ip6_int","IPAddr","IPAddr.html#method-i-ip6_int","()","<p>Returns a string for DNS reverse lookup compatible with RFC1886.\n"],["ipv4?","IPAddr","IPAddr.html#method-i-ipv4-3F","()","<p>Returns true if the ipaddr is an IPv4 address.\n"],["ipv4_compat","IPAddr","IPAddr.html#method-i-ipv4_compat","()","<p>Returns a new ipaddr built by converting the native IPv4 address into an IPv4-compatible IPv6 address. …\n"],["ipv4_compat?","IPAddr","IPAddr.html#method-i-ipv4_compat-3F","()","<p>Returns true if the ipaddr is an IPv4-compatible IPv6 address.\n"],["ipv4_mapped","IPAddr","IPAddr.html#method-i-ipv4_mapped","()","<p>Returns a new ipaddr built by converting the native IPv4 address into an IPv4-mapped IPv6 address.\n"],["ipv4_mapped?","IPAddr","IPAddr.html#method-i-ipv4_mapped-3F","()","<p>Returns true if the ipaddr is an IPv4-mapped IPv6 address.\n"],["ipv6?","IPAddr","IPAddr.html#method-i-ipv6-3F","()","<p>Returns true if the ipaddr is an IPv6 address.\n"],["link_local?","IPAddr","IPAddr.html#method-i-link_local-3F","()","<p>Returns true if the ipaddr is a link-local address.  IPv4 addresses in 169.254.0.0/16 reserved by RFC …\n"],["loopback?","IPAddr","IPAddr.html#method-i-loopback-3F","()","<p>Returns true if the ipaddr is a loopback address.\n"],["mask","IPAddr","IPAddr.html#method-i-mask","(prefixlen)","<p>Returns a new ipaddr built by masking IP address with the given prefixlen/netmask. (e.g. 8, 64, “255.255.255.0”, …\n"],["mask!","IPAddr","IPAddr.html#method-i-mask-21","(mask)","<p>Set current netmask to given mask.\n"],["native","IPAddr","IPAddr.html#method-i-native","()","<p>Returns a new ipaddr built by converting the IPv6 address into a native IPv4 address.  If the IP address …\n"],["netmask","IPAddr","IPAddr.html#method-i-netmask","()","<p>Returns the netmask in string format e.g. 255.255.0.0\n"],["new","IPAddr","IPAddr.html#method-c-new","(addr = '::', family = Socket::AF_UNSPEC)","<p>Creates a new ipaddr object either from a human readable IP address representation in string, or from …\n"],["new_ntoh","IPAddr","IPAddr.html#method-c-new_ntoh","(addr)","<p>Creates a new ipaddr containing the given network byte ordered string form of an IP address.\n"],["ntop","IPAddr","IPAddr.html#method-c-ntop","(addr)","<p>Convert a network byte ordered string form of an IP address into human readable form.\n"],["prefix","IPAddr","IPAddr.html#method-i-prefix","()","<p>Returns the prefix length in bits for the ipaddr.\n"],["prefix=","IPAddr","IPAddr.html#method-i-prefix-3D","(prefix)","<p>Sets the prefix length in bits\n"],["private?","IPAddr","IPAddr.html#method-i-private-3F","()","<p>Returns true if the ipaddr is a private address.  IPv4 addresses in 10.0.0.0/8, 172.16.0.0/12 and 192.168.0.0/16 …\n"],["reverse","IPAddr","IPAddr.html#method-i-reverse","()","<p>Returns a string for DNS reverse lookup.  It returns a string in RFC3172 form for an IPv6 address.\n"],["set","IPAddr","IPAddr.html#method-i-set","(addr, *family)","<p>Set +@addr+, the internal stored ip address, to given <code>addr</code>. The parameter <code>addr</code> is validated using the …\n"],["succ","IPAddr","IPAddr.html#method-i-succ","()","<p>Returns the successor to the ipaddr.\n"],["to_i","IPAddr","IPAddr.html#method-i-to_i","()","<p>Returns the integer representation of the ipaddr.\n"],["to_range","IPAddr","IPAddr.html#method-i-to_range","()","<p>Creates a Range object for the network address.\n"],["to_s","IPAddr","IPAddr.html#method-i-to_s","()","<p>Returns a string containing the IP address representation.\n"],["to_string","IPAddr","IPAddr.html#method-i-to_string","()","<p>Returns a string containing the IP address representation in canonical form.\n"],["valid_v6?","IPSocket","IPSocket.html#method-c-valid_v6-3F","(addr)",""],["zone_id","IPAddr","IPAddr.html#method-i-zone_id","()","<p>Returns the IPv6 zone identifier, if present. Raises InvalidAddressError if not an IPv6 address.\n"],["zone_id=","IPAddr","IPAddr.html#method-i-zone_id-3D","(zid)","<p>Returns the IPv6 zone identifier, if present. Raises InvalidAddressError if not an IPv6 address.\n"],["|","IPAddr","IPAddr.html#method-i-7C","(other)","<p>Returns a new ipaddr built by bitwise OR.\n"],["~","IPAddr","IPAddr.html#method-i-~","()","<p>Returns a new ipaddr built by bitwise negation.\n"]]}}