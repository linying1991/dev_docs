var search_data = {"index":{"searchIndex":["kernel","syntaxsuggest","aroundblockscan","blockexpand","capture","beforeafterkeywordends","fallingindentlines","capturecodecontext","cleandocument","cli","codeblock","codefrontier","codeline","codesearch","displaycodewithlinenumbers","displayinvalidblocks","error","explainsyntax","leftrightlexcount","lexall","lexvalue","ministringio","parseblocksfromindentline","pathnamefrommessage","priorityengulfqueue","priorityqueue","rippererrors","scanhistory","unvisitedlines","<<()","<<()","<=>()","<=>()","[]()","after_lines()","before_lines()","bubble_down()","bubble_up()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","can_skip_check?()","capture_before_after_kws()","capture_falling_indent()","capture_first_kw_end_same_indent()","capture_last_end_same_indent()","changed?()","clean_sweep()","code_block()","code_with_context()","combination()","commit_if_changed()","compile_error()","count()","count_end()","count_for_char()","count_kw()","count_lex()","create_blocks_from_untracked_lines()","current()","current_indent()","delete()","deleted?()","detailed_message()","detect_invalid_blocks()","display_block()","document_ok?()","each()","each_neighbor_block()","empty?()","empty?()","empty?()","empty?()","errors()","exchange()","expand?()","expand_existing()","expand_indent()","expand_neighbors()","expr_beg?()","expr_label?()","flush_deleted()","fname?()","force_add_empty()","force_add_hidden()","format()","format_line()","from_source()","handle_error()","hidden?()","hidden?()","holds_all_syntax_errors?()","ignore_newline?()","ignore_newline_not_beg?()","indent_index()","inspect()","inspect()","invalid?()","invalid?()","is_end?()","is_end?()","is_end?()","is_kw?()","is_kw?()","join_consecutive!()","join_groups()","join_heredoc!()","join_trailing_slash!()","last()","last_index()","length()","length()","lines()","lines()","lines()","lookahead_balance_one_line()","mark_invisible()","mark_invisible()","missing()","missing()","missing_keyword_end()","missing_pairs()","missing_pipe()","module_for_detailed_message()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","next_down()","next_indent_line()","next_up()","not_empty?()","on_alias_error()","on_assign_error()","on_class_name_error()","on_param_error()","on_parse_error()","parse()","parser()","peek()","peek()","peek()","pop()","pop()","pop()","pop()","prune_engulf()","push()","push()","puts()","record()","record_dir()","refresh_index()","register_engulf_block()","register_indent_block()","revert_last_commit()","scan()","scan_adjacent_indent()","scan_neighbors_not_empty()","scan_while()","set_kw_end()","set_kw_end()","skip_missing_file_name?()","sorted()","sorted_lines()","stash_changes()","stop?()","stop_after_kw()","take_while_including()","to_a()","to_a()","to_a()","to_s()","to_s()","to_s()","trailing_slash?()","valid?()","valid?()","valid_without?()","visible?()","visible_lines()","visit_block()","why()"],"longSearchIndex":["kernel","syntaxsuggest","syntaxsuggest::aroundblockscan","syntaxsuggest::blockexpand","syntaxsuggest::capture","syntaxsuggest::capture::beforeafterkeywordends","syntaxsuggest::capture::fallingindentlines","syntaxsuggest::capturecodecontext","syntaxsuggest::cleandocument","syntaxsuggest::cli","syntaxsuggest::codeblock","syntaxsuggest::codefrontier","syntaxsuggest::codeline","syntaxsuggest::codesearch","syntaxsuggest::displaycodewithlinenumbers","syntaxsuggest::displayinvalidblocks","syntaxsuggest::error","syntaxsuggest::explainsyntax","syntaxsuggest::leftrightlexcount","syntaxsuggest::lexall","syntaxsuggest::lexvalue","syntaxsuggest::ministringio","syntaxsuggest::parseblocksfromindentline","syntaxsuggest::pathnamefrommessage","syntaxsuggest::priorityengulfqueue","syntaxsuggest::priorityqueue","syntaxsuggest::rippererrors","syntaxsuggest::scanhistory","syntaxsuggest::unvisitedlines","syntaxsuggest::codefrontier#<<()","syntaxsuggest::priorityqueue#<<()","syntaxsuggest::codeblock#<=>()","syntaxsuggest::codeline#<=>()","syntaxsuggest::lexall#[]()","syntaxsuggest::scanhistory#after_lines()","syntaxsuggest::scanhistory#before_lines()","syntaxsuggest::priorityqueue#bubble_down()","syntaxsuggest::priorityqueue#bubble_up()","syntaxsuggest::call()","syntaxsuggest::blockexpand#call()","syntaxsuggest::capture::beforeafterkeywordends#call()","syntaxsuggest::capture::fallingindentlines#call()","syntaxsuggest::capturecodecontext#call()","syntaxsuggest::cleandocument#call()","syntaxsuggest::cli#call()","syntaxsuggest::codesearch#call()","syntaxsuggest::displaycodewithlinenumbers#call()","syntaxsuggest::displayinvalidblocks#call()","syntaxsuggest::explainsyntax#call()","syntaxsuggest::pathnamefrommessage#call()","syntaxsuggest::rippererrors#call()","syntaxsuggest::codefrontier#can_skip_check?()","syntaxsuggest::capturecodecontext#capture_before_after_kws()","syntaxsuggest::capturecodecontext#capture_falling_indent()","syntaxsuggest::capturecodecontext#capture_first_kw_end_same_indent()","syntaxsuggest::capturecodecontext#capture_last_end_same_indent()","syntaxsuggest::scanhistory#changed?()","syntaxsuggest::cleandocument#clean_sweep()","syntaxsuggest::aroundblockscan#code_block()","syntaxsuggest::displayinvalidblocks#code_with_context()","syntaxsuggest::codefrontier::combination()","syntaxsuggest::scanhistory#commit_if_changed()","syntaxsuggest::rippererrors#compile_error()","syntaxsuggest::codefrontier#count()","syntaxsuggest::leftrightlexcount#count_end()","syntaxsuggest::leftrightlexcount#count_for_char()","syntaxsuggest::leftrightlexcount#count_kw()","syntaxsuggest::leftrightlexcount#count_lex()","syntaxsuggest::codesearch#create_blocks_from_untracked_lines()","syntaxsuggest::scanhistory#current()","syntaxsuggest::codeblock#current_indent()","syntaxsuggest::codeblock#delete()","syntaxsuggest::codeblock#deleted?()","syntaxsuggest#detailed_message()","syntaxsuggest::codefrontier#detect_invalid_blocks()","syntaxsuggest::displayinvalidblocks#display_block()","syntaxsuggest::displayinvalidblocks#document_ok?()","syntaxsuggest::lexall#each()","syntaxsuggest::parseblocksfromindentline#each_neighbor_block()","syntaxsuggest::codeline#empty?()","syntaxsuggest::priorityengulfqueue#empty?()","syntaxsuggest::priorityqueue#empty?()","syntaxsuggest::unvisitedlines#empty?()","syntaxsuggest::explainsyntax#errors()","syntaxsuggest::priorityqueue#exchange()","syntaxsuggest::codefrontier#expand?()","syntaxsuggest::codesearch#expand_existing()","syntaxsuggest::blockexpand#expand_indent()","syntaxsuggest::blockexpand#expand_neighbors()","syntaxsuggest::lexvalue#expr_beg?()","syntaxsuggest::lexvalue#expr_label?()","syntaxsuggest::priorityengulfqueue#flush_deleted()","syntaxsuggest::lexvalue#fname?()","syntaxsuggest::aroundblockscan#force_add_empty()","syntaxsuggest::aroundblockscan#force_add_hidden()","syntaxsuggest::displaycodewithlinenumbers#format()","syntaxsuggest::displaycodewithlinenumbers#format_line()","syntaxsuggest::codeline::from_source()","syntaxsuggest::handle_error()","syntaxsuggest::codeblock#hidden?()","syntaxsuggest::codeline#hidden?()","syntaxsuggest::codefrontier#holds_all_syntax_errors?()","syntaxsuggest::lexvalue#ignore_newline?()","syntaxsuggest::codeline#ignore_newline_not_beg?()","syntaxsuggest::codeline#indent_index()","syntaxsuggest::aroundblockscan#inspect()","syntaxsuggest::blockexpand#inspect()","syntaxsuggest::invalid?()","syntaxsuggest::codeblock#invalid?()","syntaxsuggest::codeblock#is_end?()","syntaxsuggest::codeline#is_end?()","syntaxsuggest::lexvalue#is_end?()","syntaxsuggest::codeline#is_kw?()","syntaxsuggest::lexvalue#is_kw?()","syntaxsuggest::cleandocument#join_consecutive!()","syntaxsuggest::cleandocument#join_groups()","syntaxsuggest::cleandocument#join_heredoc!()","syntaxsuggest::cleandocument#join_trailing_slash!()","syntaxsuggest::lexall#last()","syntaxsuggest::priorityqueue#last_index()","syntaxsuggest::priorityengulfqueue#length()","syntaxsuggest::priorityqueue#length()","syntaxsuggest::aroundblockscan#lines()","syntaxsuggest::cleandocument#lines()","syntaxsuggest::scanhistory#lines()","syntaxsuggest::aroundblockscan#lookahead_balance_one_line()","syntaxsuggest::codeblock#mark_invisible()","syntaxsuggest::codeline#mark_invisible()","syntaxsuggest::explainsyntax#missing()","syntaxsuggest::leftrightlexcount#missing()","syntaxsuggest::leftrightlexcount#missing_keyword_end()","syntaxsuggest::leftrightlexcount#missing_pairs()","syntaxsuggest::leftrightlexcount#missing_pipe()","syntaxsuggest::module_for_detailed_message()","syntaxsuggest::aroundblockscan::new()","syntaxsuggest::blockexpand::new()","syntaxsuggest::capture::beforeafterkeywordends::new()","syntaxsuggest::capture::fallingindentlines::new()","syntaxsuggest::capturecodecontext::new()","syntaxsuggest::cleandocument::new()","syntaxsuggest::cli::new()","syntaxsuggest::codeblock::new()","syntaxsuggest::codefrontier::new()","syntaxsuggest::codeline::new()","syntaxsuggest::codesearch::new()","syntaxsuggest::displaycodewithlinenumbers::new()","syntaxsuggest::displayinvalidblocks::new()","syntaxsuggest::explainsyntax::new()","syntaxsuggest::leftrightlexcount::new()","syntaxsuggest::lexall::new()","syntaxsuggest::lexvalue::new()","syntaxsuggest::ministringio::new()","syntaxsuggest::parseblocksfromindentline::new()","syntaxsuggest::pathnamefrommessage::new()","syntaxsuggest::priorityengulfqueue::new()","syntaxsuggest::priorityqueue::new()","syntaxsuggest::scanhistory::new()","syntaxsuggest::unvisitedlines::new()","syntaxsuggest::scanhistory#next_down()","syntaxsuggest::codefrontier#next_indent_line()","syntaxsuggest::scanhistory#next_up()","syntaxsuggest::codeline#not_empty?()","syntaxsuggest::rippererrors#on_alias_error()","syntaxsuggest::rippererrors#on_assign_error()","syntaxsuggest::rippererrors#on_class_name_error()","syntaxsuggest::rippererrors#on_param_error()","syntaxsuggest::rippererrors#on_parse_error()","syntaxsuggest::cli#parse()","syntaxsuggest::cli#parser()","syntaxsuggest::priorityengulfqueue#peek()","syntaxsuggest::priorityqueue#peek()","syntaxsuggest::unvisitedlines#peek()","syntaxsuggest::codefrontier#pop()","syntaxsuggest::priorityengulfqueue#pop()","syntaxsuggest::priorityqueue#pop()","syntaxsuggest::unvisitedlines#pop()","syntaxsuggest::priorityengulfqueue#prune_engulf()","syntaxsuggest::codesearch#push()","syntaxsuggest::priorityengulfqueue#push()","syntaxsuggest::ministringio#puts()","syntaxsuggest::codesearch#record()","syntaxsuggest::record_dir()","syntaxsuggest::scanhistory#refresh_index()","syntaxsuggest::codefrontier#register_engulf_block()","syntaxsuggest::codefrontier#register_indent_block()","syntaxsuggest::scanhistory#revert_last_commit()","syntaxsuggest::scanhistory#scan()","syntaxsuggest::aroundblockscan#scan_adjacent_indent()","syntaxsuggest::aroundblockscan#scan_neighbors_not_empty()","syntaxsuggest::aroundblockscan#scan_while()","syntaxsuggest::codeline#set_kw_end()","syntaxsuggest::lexvalue#set_kw_end()","syntaxsuggest::pathnamefrommessage#skip_missing_file_name?()","syntaxsuggest::priorityqueue#sorted()","syntaxsuggest::capturecodecontext#sorted_lines()","syntaxsuggest::scanhistory#stash_changes()","syntaxsuggest::pathnamefrommessage#stop?()","syntaxsuggest::aroundblockscan#stop_after_kw()","syntaxsuggest::cleandocument#take_while_including()","syntaxsuggest::lexall#to_a()","syntaxsuggest::priorityengulfqueue#to_a()","syntaxsuggest::priorityqueue#to_a()","syntaxsuggest::cleandocument#to_s()","syntaxsuggest::codeblock#to_s()","syntaxsuggest::codeline#to_s()","syntaxsuggest::codeline#trailing_slash?()","syntaxsuggest::valid?()","syntaxsuggest::codeblock#valid?()","syntaxsuggest::valid_without?()","syntaxsuggest::codeline#visible?()","syntaxsuggest::codeblock#visible_lines()","syntaxsuggest::unvisitedlines#visit_block()","syntaxsuggest::explainsyntax#why()"],"info":[["Kernel","","Kernel.html","",""],["SyntaxSuggest","","SyntaxSuggest.html","",""],["SyntaxSuggest::AroundBlockScan","","SyntaxSuggest/AroundBlockScan.html","","<p>This class is useful for exploring contents before and after a block\n<p>It searches above and below the passed …\n"],["SyntaxSuggest::BlockExpand","","SyntaxSuggest/BlockExpand.html","","<p>This class is responsible for taking a code block that exists at a far indentaion and then iteratively …\n"],["SyntaxSuggest::Capture","","SyntaxSuggest/Capture.html","",""],["SyntaxSuggest::Capture::BeforeAfterKeywordEnds","","SyntaxSuggest/Capture/BeforeAfterKeywordEnds.html","","<p>Shows surrounding kw/end pairs\n<p>The purpose of showing these extra pairs is due to cases of ambiguity when …\n"],["SyntaxSuggest::Capture::FallingIndentLines","","SyntaxSuggest/Capture/FallingIndentLines.html","","<p>Shows the context around code provided by “falling” indentation\n<p>If this is the original code …\n"],["SyntaxSuggest::CaptureCodeContext","","SyntaxSuggest/CaptureCodeContext.html","","<p>Turns a “invalid block(s)” into useful context\n<p>There are three main phases in the algorithm: …\n"],["SyntaxSuggest::CleanDocument","","SyntaxSuggest/CleanDocument.html","","<p>Parses and sanitizes source into a lexically aware document\n<p>Internally the document is represented by …\n"],["SyntaxSuggest::Cli","","SyntaxSuggest/Cli.html","","<p>All the logic of the exe/syntax_suggest CLI in one handy spot\n\n<pre>Cli.new(argv: [&quot;--help&quot;]).call\nCli.new(argv: ...</pre>\n"],["SyntaxSuggest::CodeBlock","","SyntaxSuggest/CodeBlock.html","","<p>Multiple lines form a singular CodeBlock\n<p>Source code is made of multiple CodeBlocks.\n<p>Example:\n"],["SyntaxSuggest::CodeFrontier","","SyntaxSuggest/CodeFrontier.html","","<p>There are three main phases in the algorithm:\n<p>Sanitize/format input source\n<p>Search for invalid blocks\n"],["SyntaxSuggest::CodeLine","","SyntaxSuggest/CodeLine.html","","<p>Represents a single line of code of a given source file\n<p>This object contains metadata about the line such …\n"],["SyntaxSuggest::CodeSearch","","SyntaxSuggest/CodeSearch.html","","<p>Searches code for a syntax error\n<p>There are three main phases in the algorithm:\n<p>Sanitize/format input source …\n"],["SyntaxSuggest::DisplayCodeWithLineNumbers","","SyntaxSuggest/DisplayCodeWithLineNumbers.html","","<p>Outputs code with highlighted lines\n<p>Whatever is passed to this class will be rendered even if it is “marked …\n"],["SyntaxSuggest::DisplayInvalidBlocks","","SyntaxSuggest/DisplayInvalidBlocks.html","","<p>Used for formatting invalid blocks\n"],["SyntaxSuggest::Error","","SyntaxSuggest/Error.html","",""],["SyntaxSuggest::ExplainSyntax","","SyntaxSuggest/ExplainSyntax.html","","<p>Explains syntax errors based on their source\n<p>example:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">source</span> = <span class=\"ruby-string\">&quot;def foo; puts &#39;lol&#39;&quot;</span> <span class=\"ruby-comment\"># Note missing end ...</span>\n</pre>\n"],["SyntaxSuggest::LeftRightLexCount","","SyntaxSuggest/LeftRightLexCount.html","","<p>Find mis-matched syntax based on lexical count\n<p>Used for detecting missing pairs of elements each keyword …\n"],["SyntaxSuggest::LexAll","","SyntaxSuggest/LexAll.html","","<p>Ripper.lex is not guaranteed to lex the entire source document\n<p>lex = LexAll.new(source: source) lex.each …\n"],["SyntaxSuggest::LexValue","","SyntaxSuggest/LexValue.html","","<p>Value object for accessing lex values\n<p>This lex:\n\n<pre>[1, 0], :on_ident, &quot;describe&quot;, CMDARG</pre>\n"],["SyntaxSuggest::MiniStringIO","","SyntaxSuggest/MiniStringIO.html","","<p>Mini String IO [Private]\n<p>Acts like a StringIO with reduced API, but without having to require that class. …\n"],["SyntaxSuggest::ParseBlocksFromIndentLine","","SyntaxSuggest/ParseBlocksFromIndentLine.html","","<p>This class is responsible for generating initial code blocks that will then later be expanded.\n<p>The biggest …\n"],["SyntaxSuggest::PathnameFromMessage","","SyntaxSuggest/PathnameFromMessage.html","","<p>Converts a SyntaxError message to a path\n<p>Handles the case where the filename has a colon in it such as …\n"],["SyntaxSuggest::PriorityEngulfQueue","","SyntaxSuggest/PriorityEngulfQueue.html","","<p>Keeps track of what elements are in the queue in priority and also ensures that when one element engulfs/covers/eats …\n"],["SyntaxSuggest::PriorityQueue","","SyntaxSuggest/PriorityQueue.html","","<p>Holds elements in a priority heap on insert\n<p>Instead of constantly calling ‘sort!`, put the element where …\n"],["SyntaxSuggest::RipperErrors","","SyntaxSuggest/RipperErrors.html","","<p>Capture parse errors from ripper\n<p>Example:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">puts</span> <span class=\"ruby-constant\">RipperErrors</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&quot; def foo&quot;</span>).<span class=\"ruby-identifier\">call</span>.<span class=\"ruby-identifier\">errors</span>\n<span class=\"ruby-comment\"># =&gt; [&quot;syntax error, ...</span>\n</pre>\n"],["SyntaxSuggest::ScanHistory","","SyntaxSuggest/ScanHistory.html","","<p>Scans up/down from the given block\n<p>You can try out a change, stash it, or commit it to save for later …\n"],["SyntaxSuggest::UnvisitedLines","","SyntaxSuggest/UnvisitedLines.html","","<p>Tracks which lines various code blocks have expanded to and which are still unexplored\n"],["<<","SyntaxSuggest::CodeFrontier","SyntaxSuggest/CodeFrontier.html#method-i-3C-3C","(block)","<p>Add a block to the frontier\n<p>This method ensures the frontier always remains sorted (in indentation order) …\n"],["<<","SyntaxSuggest::PriorityQueue","SyntaxSuggest/PriorityQueue.html#method-i-3C-3C","(element)",""],["<=>","SyntaxSuggest::CodeBlock","SyntaxSuggest/CodeBlock.html#method-i-3C-3D-3E","(other)","<p>This is used for frontier ordering, we are searching from the largest indentation to the smallest. This …\n"],["<=>","SyntaxSuggest::CodeLine","SyntaxSuggest/CodeLine.html#method-i-3C-3D-3E","(other)","<p>Comparison operator, needed for equality and sorting\n"],["[]","SyntaxSuggest::LexAll","SyntaxSuggest/LexAll.html#method-i-5B-5D","(index)",""],["after_lines","SyntaxSuggest::ScanHistory","SyntaxSuggest/ScanHistory.html#method-i-after_lines","()","<p>Returns an array of all the CodeLines that exist after the currently scanned block\n"],["before_lines","SyntaxSuggest::ScanHistory","SyntaxSuggest/ScanHistory.html#method-i-before_lines","()",""],["bubble_down","SyntaxSuggest::PriorityQueue","SyntaxSuggest/PriorityQueue.html#method-i-bubble_down","(index)",""],["bubble_up","SyntaxSuggest::PriorityQueue","SyntaxSuggest/PriorityQueue.html#method-i-bubble_up","(index, element)",""],["call","SyntaxSuggest","SyntaxSuggest.html#method-c-call","(source:, filename: DEFAULT_VALUE, terminal: DEFAULT_VALUE, record_dir: DEFAULT_VALUE, timeout: TIMEOUT_DEFAULT, io: $stderr)","<p>SyntaxSuggest.call [Private]\n<p>Main private interface\n"],["call","SyntaxSuggest::BlockExpand","SyntaxSuggest/BlockExpand.html#method-i-call","(block)","<p>Main interface. Expand current indentation, before expanding to a lower indentation\n"],["call","SyntaxSuggest::Capture::BeforeAfterKeywordEnds","SyntaxSuggest/Capture/BeforeAfterKeywordEnds.html#method-i-call","()",""],["call","SyntaxSuggest::Capture::FallingIndentLines","SyntaxSuggest/Capture/FallingIndentLines.html#method-i-call","(&yieldable)",""],["call","SyntaxSuggest::CaptureCodeContext","SyntaxSuggest/CaptureCodeContext.html#method-i-call","()",""],["call","SyntaxSuggest::CleanDocument","SyntaxSuggest/CleanDocument.html#method-i-call","()","<p>Call all of the document “cleaners” and return self\n"],["call","SyntaxSuggest::Cli","SyntaxSuggest/Cli.html#method-i-call","()",""],["call","SyntaxSuggest::CodeSearch","SyntaxSuggest/CodeSearch.html#method-i-call","()","<p>Main search loop\n"],["call","SyntaxSuggest::DisplayCodeWithLineNumbers","SyntaxSuggest/DisplayCodeWithLineNumbers.html#method-i-call","()",""],["call","SyntaxSuggest::DisplayInvalidBlocks","SyntaxSuggest/DisplayInvalidBlocks.html#method-i-call","()",""],["call","SyntaxSuggest::ExplainSyntax","SyntaxSuggest/ExplainSyntax.html#method-i-call","()",""],["call","SyntaxSuggest::PathnameFromMessage","SyntaxSuggest/PathnameFromMessage.html#method-i-call","()",""],["call","SyntaxSuggest::RipperErrors","SyntaxSuggest/RipperErrors.html#method-i-call","()",""],["can_skip_check?","SyntaxSuggest::CodeFrontier","SyntaxSuggest/CodeFrontier.html#method-i-can_skip_check-3F","()","<p>Performance optimization\n<p>Parsing with ripper is expensive If we know we don’t have any blocks with …\n"],["capture_before_after_kws","SyntaxSuggest::CaptureCodeContext","SyntaxSuggest/CaptureCodeContext.html#method-i-capture_before_after_kws","(block)","<p>Shows surrounding kw/end pairs\n<p>The purpose of showing these extra pairs is due to cases of ambiguity when …\n"],["capture_falling_indent","SyntaxSuggest::CaptureCodeContext","SyntaxSuggest/CaptureCodeContext.html#method-i-capture_falling_indent","(block)","<p>Shows the context around code provided by “falling” indentation\n<p>Converts:\n\n<pre>it &quot;foo&quot; do</pre>\n"],["capture_first_kw_end_same_indent","SyntaxSuggest::CaptureCodeContext","SyntaxSuggest/CaptureCodeContext.html#method-i-capture_first_kw_end_same_indent","(block)","<p>The logical inverse of ‘capture_last_end_same_indent`\n<p>When there is an invalid block with an ‘end` missing …\n"],["capture_last_end_same_indent","SyntaxSuggest::CaptureCodeContext","SyntaxSuggest/CaptureCodeContext.html#method-i-capture_last_end_same_indent","(block)","<p>When there is an invalid block with a keyword missing an end right before another end, it is unclear …\n"],["changed?","SyntaxSuggest::ScanHistory","SyntaxSuggest/ScanHistory.html#method-i-changed-3F","()",""],["clean_sweep","SyntaxSuggest::CleanDocument","SyntaxSuggest/CleanDocument.html#method-i-clean_sweep","(source:)","<p>Remove comments\n<p>replace with empty newlines\n\n<pre>source = &lt;&lt;~&#39;EOM&#39;\n  # Comment 1\n  puts &quot;hello&quot;\n  # Comment ...</pre>\n"],["code_block","SyntaxSuggest::AroundBlockScan","SyntaxSuggest/AroundBlockScan.html#method-i-code_block","()","<p>Return the currently matched lines as a ‘CodeBlock`\n<p>When a ‘CodeBlock` is created it will gather metadata …\n"],["code_with_context","SyntaxSuggest::DisplayInvalidBlocks","SyntaxSuggest/DisplayInvalidBlocks.html#method-i-code_with_context","()",""],["combination","SyntaxSuggest::CodeFrontier","SyntaxSuggest/CodeFrontier.html#method-c-combination","(array)","<p>Example:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">combination</span>([<span class=\"ruby-value\">:a</span>, <span class=\"ruby-value\">:b</span>, <span class=\"ruby-value\">:c</span>, <span class=\"ruby-value\">:d</span>])\n<span class=\"ruby-comment\"># =&gt; [[:a], [:b], [:c], [:d], [:a, :b], [:a, :c], [:a, :d], [:b, ...</span>\n</pre>\n"],["commit_if_changed","SyntaxSuggest::ScanHistory","SyntaxSuggest/ScanHistory.html#method-i-commit_if_changed","()",""],["compile_error","SyntaxSuggest::RipperErrors","SyntaxSuggest/RipperErrors.html#method-i-compile_error","(msg)",""],["count","SyntaxSuggest::CodeFrontier","SyntaxSuggest/CodeFrontier.html#method-i-count","()",""],["count_end","SyntaxSuggest::LeftRightLexCount","SyntaxSuggest/LeftRightLexCount.html#method-i-count_end","()",""],["count_for_char","SyntaxSuggest::LeftRightLexCount","SyntaxSuggest/LeftRightLexCount.html#method-i-count_for_char","(char)",""],["count_kw","SyntaxSuggest::LeftRightLexCount","SyntaxSuggest/LeftRightLexCount.html#method-i-count_kw","()",""],["count_lex","SyntaxSuggest::LeftRightLexCount","SyntaxSuggest/LeftRightLexCount.html#method-i-count_lex","(lex)","<p>Count source code characters\n<p>Example:\n\n<pre>left_right = LeftRightLexCount.new\nleft_right.count_lex(LexValue.new(1, ...</pre>\n"],["create_blocks_from_untracked_lines","SyntaxSuggest::CodeSearch","SyntaxSuggest/CodeSearch.html#method-i-create_blocks_from_untracked_lines","()","<p>Parses the most indented lines into blocks that are marked and added to the frontier\n"],["current","SyntaxSuggest::ScanHistory","SyntaxSuggest/ScanHistory.html#method-i-current","()",""],["current_indent","SyntaxSuggest::CodeBlock","SyntaxSuggest/CodeBlock.html#method-i-current_indent","()",""],["delete","SyntaxSuggest::CodeBlock","SyntaxSuggest/CodeBlock.html#method-i-delete","()",""],["deleted?","SyntaxSuggest::CodeBlock","SyntaxSuggest/CodeBlock.html#method-i-deleted-3F","()",""],["detailed_message","SyntaxSuggest","SyntaxSuggest.html#method-i-detailed_message","(highlight: true, syntax_suggest: true, **kwargs)",""],["detect_invalid_blocks","SyntaxSuggest::CodeFrontier","SyntaxSuggest/CodeFrontier.html#method-i-detect_invalid_blocks","()","<p>Given that we know our syntax error exists somewhere in our frontier, we want to find the smallest possible …\n"],["display_block","SyntaxSuggest::DisplayInvalidBlocks","SyntaxSuggest/DisplayInvalidBlocks.html#method-i-display_block","(block)",""],["document_ok?","SyntaxSuggest::DisplayInvalidBlocks","SyntaxSuggest/DisplayInvalidBlocks.html#method-i-document_ok-3F","()",""],["each","SyntaxSuggest::LexAll","SyntaxSuggest/LexAll.html#method-i-each","()",""],["each_neighbor_block","SyntaxSuggest::ParseBlocksFromIndentLine","SyntaxSuggest/ParseBlocksFromIndentLine.html#method-i-each_neighbor_block","(target_line)","<p>Builds blocks from bottom up\n"],["empty?","SyntaxSuggest::CodeLine","SyntaxSuggest/CodeLine.html#method-i-empty-3F","()","<p>An ‘empty?` line is one that was originally left empty in the source code, while a “hidden” …\n"],["empty?","SyntaxSuggest::PriorityEngulfQueue","SyntaxSuggest/PriorityEngulfQueue.html#method-i-empty-3F","()",""],["empty?","SyntaxSuggest::PriorityQueue","SyntaxSuggest/PriorityQueue.html#method-i-empty-3F","()",""],["empty?","SyntaxSuggest::UnvisitedLines","SyntaxSuggest/UnvisitedLines.html#method-i-empty-3F","()",""],["errors","SyntaxSuggest::ExplainSyntax","SyntaxSuggest/ExplainSyntax.html#method-i-errors","()","<p>Returns an array of syntax error messages\n<p>If no missing pairs are found it falls back on the original …\n"],["exchange","SyntaxSuggest::PriorityQueue","SyntaxSuggest/PriorityQueue.html#method-i-exchange","(source, target)",""],["expand?","SyntaxSuggest::CodeFrontier","SyntaxSuggest/CodeFrontier.html#method-i-expand-3F","()",""],["expand_existing","SyntaxSuggest::CodeSearch","SyntaxSuggest/CodeSearch.html#method-i-expand_existing","()","<p>Given an already existing block in the frontier, expand it to see if it contains our invalid syntax\n"],["expand_indent","SyntaxSuggest::BlockExpand","SyntaxSuggest/BlockExpand.html#method-i-expand_indent","(block)","<p>Expands code to the next lowest indentation\n<p>For example:\n\n<pre>1 def dog\n2   print &quot;dog&quot;\n3 end</pre>\n"],["expand_neighbors","SyntaxSuggest::BlockExpand","SyntaxSuggest/BlockExpand.html#method-i-expand_neighbors","(block)","<p>A neighbor is code that is at or above the current indent line.\n<p>First we build a block with all neighbors. …\n"],["expr_beg?","SyntaxSuggest::LexValue","SyntaxSuggest/LexValue.html#method-i-expr_beg-3F","()",""],["expr_label?","SyntaxSuggest::LexValue","SyntaxSuggest/LexValue.html#method-i-expr_label-3F","()",""],["flush_deleted","SyntaxSuggest::PriorityEngulfQueue","SyntaxSuggest/PriorityEngulfQueue.html#method-i-flush_deleted","()",""],["fname?","SyntaxSuggest::LexValue","SyntaxSuggest/LexValue.html#method-i-fname-3F","()",""],["force_add_empty","SyntaxSuggest::AroundBlockScan","SyntaxSuggest/AroundBlockScan.html#method-i-force_add_empty","()","<p>When using this flag, ‘scan_while` will bypass the block it’s given and always add a line that responds …\n"],["force_add_hidden","SyntaxSuggest::AroundBlockScan","SyntaxSuggest/AroundBlockScan.html#method-i-force_add_hidden","()","<p>When using this flag, ‘scan_while` will bypass the block it’s given and always add a line that responds …\n"],["format","SyntaxSuggest::DisplayCodeWithLineNumbers","SyntaxSuggest/DisplayCodeWithLineNumbers.html#method-i-format","(contents:, number:, empty:, highlight: false)",""],["format_line","SyntaxSuggest::DisplayCodeWithLineNumbers","SyntaxSuggest/DisplayCodeWithLineNumbers.html#method-i-format_line","(code_line)",""],["from_source","SyntaxSuggest::CodeLine","SyntaxSuggest/CodeLine.html#method-c-from_source","(source, lines: nil)","<p>Returns an array of CodeLine objects from the source string\n"],["handle_error","SyntaxSuggest","SyntaxSuggest.html#method-c-handle_error","(e, re_raise: true, io: $stderr)","<p>SyntaxSuggest.handle_error [Public]\n<p>Takes a ‘SyntaxError` exception, uses the error message to locate …\n"],["hidden?","SyntaxSuggest::CodeBlock","SyntaxSuggest/CodeBlock.html#method-i-hidden-3F","()",""],["hidden?","SyntaxSuggest::CodeLine","SyntaxSuggest/CodeLine.html#method-i-hidden-3F","()","<p>Opposite or ‘visible?` (note: different than `empty?`)\n"],["holds_all_syntax_errors?","SyntaxSuggest::CodeFrontier","SyntaxSuggest/CodeFrontier.html#method-i-holds_all_syntax_errors-3F","(block_array = @queue, can_cache: true)","<p>Returns true if the document is valid with all lines removed. By default it checks all blocks in present …\n"],["ignore_newline?","SyntaxSuggest::LexValue","SyntaxSuggest/LexValue.html#method-i-ignore_newline-3F","()",""],["ignore_newline_not_beg?","SyntaxSuggest::CodeLine","SyntaxSuggest/CodeLine.html#method-i-ignore_newline_not_beg-3F","()","<p>Not stable API &mdash; Lines that have a ‘on_ignored_nl` type token and NOT a `BEG` type seem to be a good proxy …\n"],["indent_index","SyntaxSuggest::CodeLine","SyntaxSuggest/CodeLine.html#method-i-indent_index","()","<p>Used for stable sort via indentation level\n<p>Ruby’s sort is not “stable” meaning that when …\n"],["inspect","SyntaxSuggest::AroundBlockScan","SyntaxSuggest/AroundBlockScan.html#method-i-inspect","()","<p>Managable rspec errors\n"],["inspect","SyntaxSuggest::BlockExpand","SyntaxSuggest/BlockExpand.html#method-i-inspect","()","<p>Managable rspec errors\n"],["invalid?","SyntaxSuggest","SyntaxSuggest.html#method-c-invalid-3F","(source)","<p>SyntaxSuggest.invalid? [Private]\n<p>Opposite of ‘SyntaxSuggest.valid?`\n"],["invalid?","SyntaxSuggest::CodeBlock","SyntaxSuggest/CodeBlock.html#method-i-invalid-3F","()",""],["is_end?","SyntaxSuggest::CodeBlock","SyntaxSuggest/CodeBlock.html#method-i-is_end-3F","()",""],["is_end?","SyntaxSuggest::CodeLine","SyntaxSuggest/CodeLine.html#method-i-is_end-3F","()","<p>Returns true if the code line is determined to contain an ‘end` keyword\n"],["is_end?","SyntaxSuggest::LexValue","SyntaxSuggest/LexValue.html#method-i-is_end-3F","()",""],["is_kw?","SyntaxSuggest::CodeLine","SyntaxSuggest/CodeLine.html#method-i-is_kw-3F","()","<p>Returns true if the code line is determined to contain a keyword that matches with an ‘end`\n<p>For example: …\n"],["is_kw?","SyntaxSuggest::LexValue","SyntaxSuggest/LexValue.html#method-i-is_kw-3F","()",""],["join_consecutive!","SyntaxSuggest::CleanDocument","SyntaxSuggest/CleanDocument.html#method-i-join_consecutive-21","()","<p>Smushes logically “consecutive” lines\n\n<pre>source = &lt;&lt;~&#39;EOM&#39;\n  User.\n    where(name: &#39;schneems&#39;). ...</pre>\n"],["join_groups","SyntaxSuggest::CleanDocument","SyntaxSuggest/CleanDocument.html#method-i-join_groups","(groups)","<p>Helper method for joining “groups” of lines\n<p>Input is expected to be type Array&lt;Array&lt;CodeLine&gt;&gt; …\n"],["join_heredoc!","SyntaxSuggest::CleanDocument","SyntaxSuggest/CleanDocument.html#method-i-join_heredoc-21","()","<p>Smushes all heredoc lines into one line\n\n<pre>source = &lt;&lt;~&#39;EOM&#39;\n  foo = &lt;&lt;~HEREDOC\n     lol\n     hehehe\n  HEREDOC ...</pre>\n"],["join_trailing_slash!","SyntaxSuggest::CleanDocument","SyntaxSuggest/CleanDocument.html#method-i-join_trailing_slash-21","()","<p>Join lines with a trailing slash\n\n<pre>source = &lt;&lt;~&#39;EOM&#39;\n  it &quot;code can be split&quot; \\\n     &quot;across multiple lines&quot; ...</pre>\n"],["last","SyntaxSuggest::LexAll","SyntaxSuggest/LexAll.html#method-i-last","()",""],["last_index","SyntaxSuggest::PriorityQueue","SyntaxSuggest/PriorityQueue.html#method-i-last_index","()",""],["length","SyntaxSuggest::PriorityEngulfQueue","SyntaxSuggest/PriorityEngulfQueue.html#method-i-length","()",""],["length","SyntaxSuggest::PriorityQueue","SyntaxSuggest/PriorityQueue.html#method-i-length","()",""],["lines","SyntaxSuggest::AroundBlockScan","SyntaxSuggest/AroundBlockScan.html#method-i-lines","()","<p>Returns the lines matched by the current scan as an array of CodeLines\n"],["lines","SyntaxSuggest::CleanDocument","SyntaxSuggest/CleanDocument.html#method-i-lines","()","<p>Return an array of CodeLines in the document\n"],["lines","SyntaxSuggest::ScanHistory","SyntaxSuggest/ScanHistory.html#method-i-lines","()",""],["lookahead_balance_one_line","SyntaxSuggest::AroundBlockScan","SyntaxSuggest/AroundBlockScan.html#method-i-lookahead_balance_one_line","()","<p>Scanning is intentionally conservative because we have no way of rolling back an agressive block (at …\n"],["mark_invisible","SyntaxSuggest::CodeBlock","SyntaxSuggest/CodeBlock.html#method-i-mark_invisible","()",""],["mark_invisible","SyntaxSuggest::CodeLine","SyntaxSuggest/CodeLine.html#method-i-mark_invisible","()","<p>Used to hide lines\n<p>The search alorithm will group lines into blocks then if those blocks are determined …\n"],["missing","SyntaxSuggest::ExplainSyntax","SyntaxSuggest/ExplainSyntax.html#method-i-missing","()","<p>Returns an array of missing elements\n<p>For example this:\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">ExplainSyntax</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-value\">code_lines:</span> <span class=\"ruby-identifier\">lines</span>).<span class=\"ruby-identifier\">missing</span>\n<span class=\"ruby-comment\"># =&gt; ...</span>\n</pre>\n"],["missing","SyntaxSuggest::LeftRightLexCount","SyntaxSuggest/LeftRightLexCount.html#method-i-missing","()","<p>Returns an array of missing syntax characters or ‘“end”` or `“keyword”`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">left_right</span>.<span class=\"ruby-identifier\">missing</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["missing_keyword_end","SyntaxSuggest::LeftRightLexCount","SyntaxSuggest/LeftRightLexCount.html#method-i-missing_keyword_end","()","<p>Keywords need ends and ends need keywords\n<p>If we have more keywords, there’s a missing ‘end` if we …\n"],["missing_pairs","SyntaxSuggest::LeftRightLexCount","SyntaxSuggest/LeftRightLexCount.html#method-i-missing_pairs","()","<p>Opening characters like ‘{` need closing characters # like `}`.\n<p>When a mis-match count is detected, suggest …\n"],["missing_pipe","SyntaxSuggest::LeftRightLexCount","SyntaxSuggest/LeftRightLexCount.html#method-i-missing_pipe","()","<p>Pipes come in pairs. If there’s an odd number of pipes then we are missing one\n"],["module_for_detailed_message","SyntaxSuggest","SyntaxSuggest.html#method-c-module_for_detailed_message","()","<p>SyntaxSuggest.record_dir [Private]\n<p>Used to monkeypatch SyntaxError via Module.prepend\n"],["new","SyntaxSuggest::AroundBlockScan","SyntaxSuggest/AroundBlockScan.html#method-c-new","(code_lines:, block:)",""],["new","SyntaxSuggest::BlockExpand","SyntaxSuggest/BlockExpand.html#method-c-new","(code_lines:)",""],["new","SyntaxSuggest::Capture::BeforeAfterKeywordEnds","SyntaxSuggest/Capture/BeforeAfterKeywordEnds.html#method-c-new","(code_lines:, block:)",""],["new","SyntaxSuggest::Capture::FallingIndentLines","SyntaxSuggest/Capture/FallingIndentLines.html#method-c-new","(code_lines:, block:)",""],["new","SyntaxSuggest::CaptureCodeContext","SyntaxSuggest/CaptureCodeContext.html#method-c-new","(blocks:, code_lines:)",""],["new","SyntaxSuggest::CleanDocument","SyntaxSuggest/CleanDocument.html#method-c-new","(source:)",""],["new","SyntaxSuggest::Cli","SyntaxSuggest/Cli.html#method-c-new","(argv:, exit_obj: Kernel, io: $stdout, env: ENV)","<p>ARGV is Everything passed to the executable, does not include executable name\n<p>All other intputs are dependency …\n"],["new","SyntaxSuggest::CodeBlock","SyntaxSuggest/CodeBlock.html#method-c-new","(lines: [])",""],["new","SyntaxSuggest::CodeFrontier","SyntaxSuggest/CodeFrontier.html#method-c-new","(code_lines:, unvisited: UnvisitedLines.new(code_lines: code_lines))",""],["new","SyntaxSuggest::CodeLine","SyntaxSuggest/CodeLine.html#method-c-new","(line:, index:, lex:)",""],["new","SyntaxSuggest::CodeSearch","SyntaxSuggest/CodeSearch.html#method-c-new","(source, record_dir: DEFAULT_VALUE)",""],["new","SyntaxSuggest::DisplayCodeWithLineNumbers","SyntaxSuggest/DisplayCodeWithLineNumbers.html#method-c-new","(lines:, highlight_lines: [], terminal: false)",""],["new","SyntaxSuggest::DisplayInvalidBlocks","SyntaxSuggest/DisplayInvalidBlocks.html#method-c-new","(code_lines:, blocks:, io: $stderr, filename: nil, terminal: DEFAULT_VALUE)",""],["new","SyntaxSuggest::ExplainSyntax","SyntaxSuggest/ExplainSyntax.html#method-c-new","(code_lines:)",""],["new","SyntaxSuggest::LeftRightLexCount","SyntaxSuggest/LeftRightLexCount.html#method-c-new","()",""],["new","SyntaxSuggest::LexAll","SyntaxSuggest/LexAll.html#method-c-new","(source:, source_lines: nil)",""],["new","SyntaxSuggest::LexValue","SyntaxSuggest/LexValue.html#method-c-new","(line, type, token, state, last_lex = nil)",""],["new","SyntaxSuggest::MiniStringIO","SyntaxSuggest/MiniStringIO.html#method-c-new","(isatty: $stderr.isatty)",""],["new","SyntaxSuggest::ParseBlocksFromIndentLine","SyntaxSuggest/ParseBlocksFromIndentLine.html#method-c-new","(code_lines:)",""],["new","SyntaxSuggest::PathnameFromMessage","SyntaxSuggest/PathnameFromMessage.html#method-c-new","(message, io: $stderr)",""],["new","SyntaxSuggest::PriorityEngulfQueue","SyntaxSuggest/PriorityEngulfQueue.html#method-c-new","()",""],["new","SyntaxSuggest::PriorityQueue","SyntaxSuggest/PriorityQueue.html#method-c-new","()",""],["new","SyntaxSuggest::ScanHistory","SyntaxSuggest/ScanHistory.html#method-c-new","(code_lines:, block:)",""],["new","SyntaxSuggest::UnvisitedLines","SyntaxSuggest/UnvisitedLines.html#method-c-new","(code_lines:)",""],["next_down","SyntaxSuggest::ScanHistory","SyntaxSuggest/ScanHistory.html#method-i-next_down","()",""],["next_indent_line","SyntaxSuggest::CodeFrontier","SyntaxSuggest/CodeFrontier.html#method-i-next_indent_line","()",""],["next_up","SyntaxSuggest::ScanHistory","SyntaxSuggest/ScanHistory.html#method-i-next_up","()",""],["not_empty?","SyntaxSuggest::CodeLine","SyntaxSuggest/CodeLine.html#method-i-not_empty-3F","()","<p>Opposite of ‘empty?` (note: different than `visible?`)\n"],["on_alias_error","SyntaxSuggest::RipperErrors","SyntaxSuggest/RipperErrors.html#method-i-on_alias_error","(msg)",""],["on_assign_error","SyntaxSuggest::RipperErrors","SyntaxSuggest/RipperErrors.html#method-i-on_assign_error","(msg)",""],["on_class_name_error","SyntaxSuggest::RipperErrors","SyntaxSuggest/RipperErrors.html#method-i-on_class_name_error","(msg)",""],["on_param_error","SyntaxSuggest::RipperErrors","SyntaxSuggest/RipperErrors.html#method-i-on_param_error","(msg)",""],["on_parse_error","SyntaxSuggest::RipperErrors","SyntaxSuggest/RipperErrors.html#method-i-on_parse_error","(msg)","<p>Comes from ripper, called on every parse error, msg is a string\n"],["parse","SyntaxSuggest::Cli","SyntaxSuggest/Cli.html#method-i-parse","()",""],["parser","SyntaxSuggest::Cli","SyntaxSuggest/Cli.html#method-i-parser","()",""],["peek","SyntaxSuggest::PriorityEngulfQueue","SyntaxSuggest/PriorityEngulfQueue.html#method-i-peek","()",""],["peek","SyntaxSuggest::PriorityQueue","SyntaxSuggest/PriorityQueue.html#method-i-peek","()",""],["peek","SyntaxSuggest::UnvisitedLines","SyntaxSuggest/UnvisitedLines.html#method-i-peek","()",""],["pop","SyntaxSuggest::CodeFrontier","SyntaxSuggest/CodeFrontier.html#method-i-pop","()","<p>Returns a code block with the largest indentation possible\n"],["pop","SyntaxSuggest::PriorityEngulfQueue","SyntaxSuggest/PriorityEngulfQueue.html#method-i-pop","()",""],["pop","SyntaxSuggest::PriorityQueue","SyntaxSuggest/PriorityQueue.html#method-i-pop","()",""],["pop","SyntaxSuggest::UnvisitedLines","SyntaxSuggest/UnvisitedLines.html#method-i-pop","()",""],["prune_engulf","SyntaxSuggest::PriorityEngulfQueue","SyntaxSuggest/PriorityEngulfQueue.html#method-i-prune_engulf","(block)",""],["push","SyntaxSuggest::CodeSearch","SyntaxSuggest/CodeSearch.html#method-i-push","(block, name:)",""],["push","SyntaxSuggest::PriorityEngulfQueue","SyntaxSuggest/PriorityEngulfQueue.html#method-i-push","(block)",""],["puts","SyntaxSuggest::MiniStringIO","SyntaxSuggest/MiniStringIO.html#method-i-puts","(value = $/, **)",""],["record","SyntaxSuggest::CodeSearch","SyntaxSuggest/CodeSearch.html#method-i-record","(block:, name: \"record\")","<p>Used for debugging\n"],["record_dir","SyntaxSuggest","SyntaxSuggest.html#method-c-record_dir","(dir)","<p>SyntaxSuggest.record_dir [Private]\n<p>Used to generate a unique directory to record search steps for debugging …\n"],["refresh_index","SyntaxSuggest::ScanHistory","SyntaxSuggest/ScanHistory.html#method-i-refresh_index","()",""],["register_engulf_block","SyntaxSuggest::CodeFrontier","SyntaxSuggest/CodeFrontier.html#method-i-register_engulf_block","(block)","<p>When one element fully encapsulates another we remove the smaller block from the frontier. This prevents …\n"],["register_indent_block","SyntaxSuggest::CodeFrontier","SyntaxSuggest/CodeFrontier.html#method-i-register_indent_block","(block)","<p>Keeps track of what lines have been added to blocks and which are not yet visited.\n"],["revert_last_commit","SyntaxSuggest::ScanHistory","SyntaxSuggest/ScanHistory.html#method-i-revert_last_commit","()","<p>Discard changes that have not been committed and revert the last commit\n<p>Cannot revert the first commit …\n"],["scan","SyntaxSuggest::ScanHistory","SyntaxSuggest/ScanHistory.html#method-i-scan","(up:, down:)","<p>Iterates up and down\n<p>Returns line, kw_count, end_count for each iteration\n"],["scan_adjacent_indent","SyntaxSuggest::AroundBlockScan","SyntaxSuggest/AroundBlockScan.html#method-i-scan_adjacent_indent","()","<p>Scan blocks based on indentation of next line above/below block\n<p>Determines indentaion of the next line …\n"],["scan_neighbors_not_empty","SyntaxSuggest::AroundBlockScan","SyntaxSuggest/AroundBlockScan.html#method-i-scan_neighbors_not_empty","()","<p>Finds code lines at the same or greater indentation and adds them to the block\n"],["scan_while","SyntaxSuggest::AroundBlockScan","SyntaxSuggest/AroundBlockScan.html#method-i-scan_while","()","<p>Main work method\n<p>The scan_while method takes a block that yields lines above and below the block. If the …\n"],["set_kw_end","SyntaxSuggest::CodeLine","SyntaxSuggest/CodeLine.html#method-i-set_kw_end","()","<p>Endless method detection\n<p>From github.com/ruby/irb/commit/826ae909c9c93a2ddca6f9cfcd9c94dbf53d44ab Detecting …\n"],["set_kw_end","SyntaxSuggest::LexValue","SyntaxSuggest/LexValue.html#method-i-set_kw_end","(last_lex)",""],["skip_missing_file_name?","SyntaxSuggest::PathnameFromMessage","SyntaxSuggest/PathnameFromMessage.html#method-i-skip_missing_file_name-3F","()",""],["sorted","SyntaxSuggest::PriorityQueue","SyntaxSuggest/PriorityQueue.html#method-i-sorted","()","<p>Used for testing, extremely not performant\n"],["sorted_lines","SyntaxSuggest::CaptureCodeContext","SyntaxSuggest/CaptureCodeContext.html#method-i-sorted_lines","()",""],["stash_changes","SyntaxSuggest::ScanHistory","SyntaxSuggest/ScanHistory.html#method-i-stash_changes","()","<p>Discards any changes that have not been committed\n"],["stop?","SyntaxSuggest::PathnameFromMessage","SyntaxSuggest/PathnameFromMessage.html#method-i-stop-3F","()",""],["stop_after_kw","SyntaxSuggest::AroundBlockScan","SyntaxSuggest/AroundBlockScan.html#method-i-stop_after_kw","()","<p>Tells ‘scan_while` to look for mismatched keyword/end-s\n<p>When scanning up, if we see more keywords then …\n"],["take_while_including","SyntaxSuggest::CleanDocument","SyntaxSuggest/CleanDocument.html#method-i-take_while_including","(range = 0..-1)","<p>Helper method for grabbing elements from document\n<p>Like ‘take_while` except when it stops iterating, it …\n"],["to_a","SyntaxSuggest::LexAll","SyntaxSuggest/LexAll.html#method-i-to_a","()",""],["to_a","SyntaxSuggest::PriorityEngulfQueue","SyntaxSuggest/PriorityEngulfQueue.html#method-i-to_a","()",""],["to_a","SyntaxSuggest::PriorityQueue","SyntaxSuggest/PriorityQueue.html#method-i-to_a","()",""],["to_s","SyntaxSuggest::CleanDocument","SyntaxSuggest/CleanDocument.html#method-i-to_s","()","<p>Renders the document back to a string\n"],["to_s","SyntaxSuggest::CodeBlock","SyntaxSuggest/CodeBlock.html#method-i-to_s","()",""],["to_s","SyntaxSuggest::CodeLine","SyntaxSuggest/CodeLine.html#method-i-to_s","()","<p>Renders the given line\n<p>Also allows us to represent source code as an array of code lines.\n<p>When we have …\n"],["trailing_slash?","SyntaxSuggest::CodeLine","SyntaxSuggest/CodeLine.html#method-i-trailing_slash-3F","()","<p>Determines if the given line has a trailing slash\n\n<pre>lines = CodeLine.from_source(&lt;&lt;~EOM)\n  it &quot;foo&quot; \\\nEOM ...</pre>\n"],["valid?","SyntaxSuggest","SyntaxSuggest.html#method-c-valid-3F","(source)","<p>SyntaxSuggest.valid? [Private]\n<p>Returns truthy if a given input source is valid syntax\n\n<pre>SyntaxSuggest.valid?(&lt;&lt;~EOM) ...</pre>\n"],["valid?","SyntaxSuggest::CodeBlock","SyntaxSuggest/CodeBlock.html#method-i-valid-3F","()",""],["valid_without?","SyntaxSuggest","SyntaxSuggest.html#method-c-valid_without-3F","(without_lines:, code_lines:)","<p>SyntaxSuggest.valid_without? [Private]\n<p>This will tell you if the ‘code_lines` would be valid if you removed …\n"],["visible?","SyntaxSuggest::CodeLine","SyntaxSuggest/CodeLine.html#method-i-visible-3F","()","<p>Means the line was marked as “invisible” Confusingly, “empty” lines are visible…they …\n"],["visible_lines","SyntaxSuggest::CodeBlock","SyntaxSuggest/CodeBlock.html#method-i-visible_lines","()",""],["visit_block","SyntaxSuggest::UnvisitedLines","SyntaxSuggest/UnvisitedLines.html#method-i-visit_block","(block)",""],["why","SyntaxSuggest::ExplainSyntax","SyntaxSuggest/ExplainSyntax.html#method-i-why","(miss)","<p>Converts a missing string to an human understandable explanation.\n<p>Example:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">explain</span>.<span class=\"ruby-identifier\">why</span>(<span class=\"ruby-string\">&quot;}&quot;</span>)\n<span class=\"ruby-comment\"># =&gt; &quot;Unmatched ...</span>\n</pre>\n"]]}}