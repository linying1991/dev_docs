var search_data = {"index":{"searchIndex":["exceptionformatrix","errdimensionmismatch","errnotregular","erroperationnotdefined","erroperationnotimplemented","matrix","eigenvaluedecomposition","lupdecomposition","vector","zerovectorerror","*()","*()","**()","+()","+()","+@()","+@()","-()","-()","-@()","-@()","/()","/()","==()","==()","i()","[]()","[]()","[]()","[]()","[]=()","[]=()","abs()","adjoint()","adjugate()","angle_with()","antisymmetric?()","basis()","build()","build_eigenvectors()","cdiv()","check_int()","check_range()","coerce()","coerce()","cofactor()","cofactor_expansion()","collect()","collect()","collect!()","collect!()","collect2()","column()","column_vector()","column_vectors()","columns()","combine()","combine()","component()","component()","conj()","conjugate()","covector()","cross()","cross_product()","d()","det()","det()","det_e()","determinant()","determinant()","determinant_bareiss()","determinant_e()","diagonal()","diagonal?()","diagonalize()","dot()","each()","each()","each2()","each_with_index()","eigen()","eigensystem()","eigenvalue_matrix()","eigenvalues()","eigenvector_matrix()","eigenvector_matrix_inv()","eigenvectors()","element()","element()","elements()","elements_to_f()","elements_to_f()","elements_to_i()","elements_to_i()","elements_to_r()","elements_to_r()","empty()","empty?()","entrywise_product()","eql?()","eql?()","find_index()","first_minor()","freeze()","freeze()","hadamard_product()","hash()","hash()","hermitian?()","hessenberg_to_real_schur()","hstack()","hstack()","identity()","imag()","imaginary()","independent?()","independent?()","index()","initialize_copy()","initialize_copy()","inner_product()","inspect()","inspect()","inv()","inverse()","l()","laplace_expansion()","lower_triangular?()","lup()","lup_decomposition()","magnitude()","map()","map()","map!()","map!()","map2()","minor()","new()","new()","new()","new()","new()","new()","new()","new()","norm()","normal?()","normalize()","orthogonal?()","p()","permutation?()","power_int()","r()","rank()","rank_e()","real()","real?()","rect()","rectangular()","reduce_to_hessenberg()","regular?()","rotate_entries()","round()","round()","row()","row_count()","row_size()","row_vector()","row_vectors()","rows()","scalar()","set_col_range()","set_column_vector()","set_component()","set_component()","set_element()","set_element()","set_range()","set_row_and_col_range()","set_row_range()","set_value()","set_value()","singular?()","singular?()","size()","skew_symmetric?()","solve()","square?()","symmetric?()","t()","to_a()","to_a()","to_a()","to_a()","to_ary()","to_ary()","to_matrix()","to_matrix()","to_s()","to_s()","tr()","trace()","transpose()","tridiagonalize()","u()","unit()","unitary?()","upper_triangular?()","v()","v_inv()","vstack()","vstack()","zero()","zero()","zero?()","zero?()"],"longSearchIndex":["exceptionformatrix","exceptionformatrix::errdimensionmismatch","exceptionformatrix::errnotregular","exceptionformatrix::erroperationnotdefined","exceptionformatrix::erroperationnotimplemented","matrix","matrix::eigenvaluedecomposition","matrix::lupdecomposition","vector","vector::zerovectorerror","matrix#*()","vector#*()","matrix#**()","matrix#+()","vector#+()","matrix#+@()","vector#+@()","matrix#-()","vector#-()","matrix#-@()","vector#-@()","matrix#/()","vector#/()","matrix#==()","vector#==()","matrix::i()","matrix::[]()","matrix#[]()","vector::[]()","vector#[]()","matrix#[]=()","vector#[]=()","matrix#abs()","matrix#adjoint()","matrix#adjugate()","vector#angle_with()","matrix#antisymmetric?()","vector::basis()","matrix::build()","matrix::eigenvaluedecomposition#build_eigenvectors()","matrix::eigenvaluedecomposition#cdiv()","matrix#check_int()","matrix#check_range()","matrix#coerce()","vector#coerce()","matrix#cofactor()","matrix#cofactor_expansion()","matrix#collect()","vector#collect()","matrix#collect!()","vector#collect!()","vector#collect2()","matrix#column()","matrix::column_vector()","matrix#column_vectors()","matrix::columns()","matrix::combine()","matrix#combine()","matrix#component()","vector#component()","matrix#conj()","matrix#conjugate()","vector#covector()","vector#cross()","vector#cross_product()","matrix::eigenvaluedecomposition#d()","matrix#det()","matrix::lupdecomposition#det()","matrix#det_e()","matrix#determinant()","matrix::lupdecomposition#determinant()","matrix#determinant_bareiss()","matrix#determinant_e()","matrix::diagonal()","matrix#diagonal?()","matrix::eigenvaluedecomposition#diagonalize()","vector#dot()","matrix#each()","vector#each()","vector#each2()","matrix#each_with_index()","matrix#eigen()","matrix#eigensystem()","matrix::eigenvaluedecomposition#eigenvalue_matrix()","matrix::eigenvaluedecomposition#eigenvalues()","matrix::eigenvaluedecomposition#eigenvector_matrix()","matrix::eigenvaluedecomposition#eigenvector_matrix_inv()","matrix::eigenvaluedecomposition#eigenvectors()","matrix#element()","vector#element()","vector::elements()","matrix#elements_to_f()","vector#elements_to_f()","matrix#elements_to_i()","vector#elements_to_i()","matrix#elements_to_r()","vector#elements_to_r()","matrix::empty()","matrix#empty?()","matrix#entrywise_product()","matrix#eql?()","vector#eql?()","matrix#find_index()","matrix#first_minor()","matrix#freeze()","vector#freeze()","matrix#hadamard_product()","matrix#hash()","vector#hash()","matrix#hermitian?()","matrix::eigenvaluedecomposition#hessenberg_to_real_schur()","matrix::hstack()","matrix#hstack()","matrix::identity()","matrix#imag()","matrix#imaginary()","vector::independent?()","vector#independent?()","matrix#index()","matrix#initialize_copy()","vector#initialize_copy()","vector#inner_product()","matrix#inspect()","vector#inspect()","matrix#inv()","matrix#inverse()","matrix::lupdecomposition#l()","matrix#laplace_expansion()","matrix#lower_triangular?()","matrix#lup()","matrix#lup_decomposition()","vector#magnitude()","matrix#map()","vector#map()","matrix#map!()","vector#map!()","vector#map2()","matrix#minor()","exceptionformatrix::errdimensionmismatch::new()","exceptionformatrix::errnotregular::new()","exceptionformatrix::erroperationnotdefined::new()","exceptionformatrix::erroperationnotimplemented::new()","matrix::new()","matrix::eigenvaluedecomposition::new()","matrix::lupdecomposition::new()","vector::new()","vector#norm()","matrix#normal?()","vector#normalize()","matrix#orthogonal?()","matrix::lupdecomposition#p()","matrix#permutation?()","matrix#power_int()","vector#r()","matrix#rank()","matrix#rank_e()","matrix#real()","matrix#real?()","matrix#rect()","matrix#rectangular()","matrix::eigenvaluedecomposition#reduce_to_hessenberg()","matrix#regular?()","matrix#rotate_entries()","matrix#round()","vector#round()","matrix#row()","matrix#row_count()","matrix#row_size()","matrix::row_vector()","matrix#row_vectors()","matrix::rows()","matrix::scalar()","matrix#set_col_range()","matrix#set_column_vector()","matrix#set_component()","vector#set_component()","matrix#set_element()","vector#set_element()","vector#set_range()","matrix#set_row_and_col_range()","matrix#set_row_range()","matrix#set_value()","vector#set_value()","matrix#singular?()","matrix::lupdecomposition#singular?()","vector#size()","matrix#skew_symmetric?()","matrix::lupdecomposition#solve()","matrix#square?()","matrix#symmetric?()","matrix#t()","matrix#to_a()","matrix::eigenvaluedecomposition#to_a()","matrix::lupdecomposition#to_a()","vector#to_a()","matrix::eigenvaluedecomposition#to_ary()","matrix::lupdecomposition#to_ary()","matrix#to_matrix()","vector#to_matrix()","matrix#to_s()","vector#to_s()","matrix#tr()","matrix#trace()","matrix#transpose()","matrix::eigenvaluedecomposition#tridiagonalize()","matrix::lupdecomposition#u()","matrix::unit()","matrix#unitary?()","matrix#upper_triangular?()","matrix::eigenvaluedecomposition#v()","matrix::eigenvaluedecomposition#v_inv()","matrix::vstack()","matrix#vstack()","matrix::zero()","vector::zero()","matrix#zero?()","vector#zero?()"],"info":[["ExceptionForMatrix","","ExceptionForMatrix.html","",""],["ExceptionForMatrix::ErrDimensionMismatch","","ExceptionForMatrix/ErrDimensionMismatch.html","",""],["ExceptionForMatrix::ErrNotRegular","","ExceptionForMatrix/ErrNotRegular.html","",""],["ExceptionForMatrix::ErrOperationNotDefined","","ExceptionForMatrix/ErrOperationNotDefined.html","",""],["ExceptionForMatrix::ErrOperationNotImplemented","","ExceptionForMatrix/ErrOperationNotImplemented.html","",""],["Matrix","","Matrix.html","","<p>The <code>Matrix</code> class represents a mathematical matrix. It provides methods for creating matrices, operating …\n"],["Matrix::EigenvalueDecomposition","","Matrix/EigenvalueDecomposition.html","","<p>Eigenvalues and eigenvectors of a real matrix.\n<p>Computes the eigenvalues and eigenvectors of a matrix  …\n"],["Matrix::LUPDecomposition","","Matrix/LUPDecomposition.html","","<p>For an m-by-n matrix A with m &gt;= n, the LU decomposition is an m-by-n unit lower triangular matrix …\n"],["Vector","","Vector.html","","<p>The <code>Vector</code> class represents a mathematical vector, which is useful in its own right, and also constitutes …\n"],["Vector::ZeroVectorError","","Vector/ZeroVectorError.html","",""],["*","Matrix","Matrix.html#method-i-2A","(m)","<p>Matrix multiplication.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">2</span>,<span class=\"ruby-value\">4</span>], [<span class=\"ruby-value\">6</span>,<span class=\"ruby-value\">8</span>]] <span class=\"ruby-operator\">*</span> <span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">identity</span>(<span class=\"ruby-value\">2</span>)\n<span class=\"ruby-comment\">#  =&gt; 2 4</span>\n<span class=\"ruby-comment\">#     6 8</span>\n</pre>\n"],["*","Vector","Vector.html#method-i-2A","(x)","<p>Multiplies the vector by <code>x</code>, where <code>x</code> is a number or a matrix.\n"],["**","Matrix","Matrix.html#method-i-2A-2A","(exp)","<p>Matrix exponentiation. Equivalent to multiplying the matrix by itself N times. Non integer exponents …\n"],["+","Matrix","Matrix.html#method-i-2B","(m)","<p>Matrix addition.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">scalar</span>(<span class=\"ruby-value\">2</span>,<span class=\"ruby-value\">5</span>) <span class=\"ruby-operator\">+</span> <span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span>], [<span class=\"ruby-value\">-4</span>,<span class=\"ruby-value\">7</span>]]\n<span class=\"ruby-comment\">#  =&gt;  6  0</span>\n<span class=\"ruby-comment\">#     -4 12</span>\n</pre>\n"],["+","Vector","Vector.html#method-i-2B","(v)","<p>Vector addition.\n"],["+@","Matrix","Matrix.html#method-i-2B-40","()",""],["+@","Vector","Vector.html#method-i-2B-40","()",""],["-","Matrix","Matrix.html#method-i-2D","(m)","<p>Matrix subtraction.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">5</span>], [<span class=\"ruby-value\">4</span>,<span class=\"ruby-value\">2</span>]] <span class=\"ruby-operator\">-</span> <span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">9</span>,<span class=\"ruby-value\">3</span>], [<span class=\"ruby-value\">-4</span>,<span class=\"ruby-value\">1</span>]]\n<span class=\"ruby-comment\">#  =&gt; -8  2</span>\n<span class=\"ruby-comment\">#      8  1</span>\n</pre>\n"],["-","Vector","Vector.html#method-i-2D","(v)","<p>Vector subtraction.\n"],["-@","Matrix","Matrix.html#method-i-2D-40","()","<p>Unary matrix negation.\n\n<pre class=\"ruby\"><span class=\"ruby-operator\">-</span><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">5</span>], [<span class=\"ruby-value\">4</span>,<span class=\"ruby-value\">2</span>]]\n<span class=\"ruby-comment\"># =&gt; -1 -5</span>\n<span class=\"ruby-comment\">#    -4 -2</span>\n</pre>\n"],["-@","Vector","Vector.html#method-i-2D-40","()",""],["/","Matrix","Matrix.html#method-i-2F","(other)","<p>Matrix division (multiplication by the inverse).\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">7</span>,<span class=\"ruby-value\">6</span>], [<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">9</span>]] <span class=\"ruby-operator\">/</span> <span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">2</span>,<span class=\"ruby-value\">9</span>], [<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">1</span>]]\n<span class=\"ruby-comment\">#  =&gt; -7 ...</span>\n</pre>\n"],["/","Vector","Vector.html#method-i-2F","(x)","<p>Vector division.\n"],["==","Matrix","Matrix.html#method-i-3D-3D","(other)","<p>Returns whether the two matrices contain equal elements.\n"],["==","Vector","Vector.html#method-i-3D-3D","(other)","<p>Returns whether the two vectors have the same elements in the same order.\n"],["I","Matrix","Matrix.html#method-c-I","(n)",""],["[]","Matrix","Matrix.html#method-c-5B-5D","(*rows)","<p>Creates a matrix where each argument is a row.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[ [<span class=\"ruby-value\">25</span>, <span class=\"ruby-value\">93</span>], [<span class=\"ruby-value\">-1</span>, <span class=\"ruby-value\">66</span>] ]\n<span class=\"ruby-comment\">#   =&gt;  25 93</span>\n<span class=\"ruby-comment\">#       -1 66</span>\n</pre>\n"],["[]","Matrix","Matrix.html#method-i-5B-5D","(i, j)","<p>Returns element (<code>i</code>,<code>j</code>) of the matrix.  That is: row <code>i</code>, column <code>j</code>.\n"],["[]","Vector","Vector.html#method-c-5B-5D","(*array)","<p>Creates a Vector from a list of elements.\n\n<pre>Vector[7, 4, ...]</pre>\n"],["[]","Vector","Vector.html#method-i-5B-5D","(i)","<p>Returns element or elements of the vector.\n"],["[]=","Matrix","Matrix.html#method-i-5B-5D-3D","(i, j, v)","<p>Set element or elements of matrix.\n"],["[]=","Vector","Vector.html#method-i-5B-5D-3D","(i, v)","<p>Set element or elements of vector.\n"],["abs","Matrix","Matrix.html#method-i-abs","()","<p>Returns the absolute value elementwise\n"],["adjoint","Matrix","Matrix.html#method-i-adjoint","()","<p>Returns the adjoint of the matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[ [<span class=\"ruby-identifier\">i</span>,<span class=\"ruby-value\">1</span>],[<span class=\"ruby-value\">2</span>,<span class=\"ruby-operator\">-</span><span class=\"ruby-identifier\">i</span>] ].<span class=\"ruby-identifier\">adjoint</span>\n<span class=\"ruby-comment\">#  =&gt; -i 2</span>\n<span class=\"ruby-comment\">#      1 i</span>\n</pre>\n"],["adjugate","Matrix","Matrix.html#method-i-adjugate","()","<p>Returns the adjugate of the matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[ [<span class=\"ruby-value\">7</span>,<span class=\"ruby-value\">6</span>],[<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">9</span>] ].<span class=\"ruby-identifier\">adjugate</span>\n<span class=\"ruby-comment\">#  =&gt; 9 -6</span>\n<span class=\"ruby-comment\">#     -3 7</span>\n</pre>\n"],["angle_with","Vector","Vector.html#method-i-angle_with","(v)","<p>Returns an angle with another vector. Result is within the [0..Math::PI].\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span>].<span class=\"ruby-identifier\">angle_with</span>(<span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">0</span>,<span class=\"ruby-value\">1</span>]) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["antisymmetric?","Matrix","Matrix.html#method-i-antisymmetric-3F","()","<p>Returns <code>true</code> if this is an antisymmetric matrix. Raises an error if matrix is not square.\n"],["basis","Vector","Vector.html#method-c-basis","(size:, index:)","<p>Returns a standard basis <code>n</code>-vector, where k is the index.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Vector</span>.<span class=\"ruby-identifier\">basis</span>(<span class=\"ruby-value\">size:</span>, <span class=\"ruby-value\">index:</span>) <span class=\"ruby-comment\"># =&gt; Vector[0, 1, ...</span>\n</pre>\n"],["build","Matrix","Matrix.html#method-c-build","(row_count, column_count = row_count)","<p>Creates a matrix of size <code>row_count</code> x <code>column_count</code>. It fills the values by calling the given block, passing …\n"],["build_eigenvectors","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-build_eigenvectors","()",""],["cdiv","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-cdiv","(xr, xi, yr, yi)","<p>Complex scalar division.\n"],["check_int","Matrix","Matrix.html#method-i-check_int","(val, direction)",""],["check_range","Matrix","Matrix.html#method-i-check_range","(val, direction)","<p>Returns range or nil\n"],["coerce","Matrix","Matrix.html#method-i-coerce","(other)","<p>The coerce method provides support for Ruby type coercion. This coercion mechanism is used by Ruby to …\n"],["coerce","Vector","Vector.html#method-i-coerce","(other)","<p>The coerce method provides support for Ruby type coercion. This coercion mechanism is used by Ruby to …\n"],["cofactor","Matrix","Matrix.html#method-i-cofactor","(row, column)","<p>Returns the (row, column) cofactor which is obtained by multiplying the first minor by (-1)**(row + column). …\n"],["cofactor_expansion","Matrix","Matrix.html#method-i-cofactor_expansion","(row: nil, column: nil)",""],["collect","Matrix","Matrix.html#method-i-collect","(which = :all)","<p>Returns a matrix that is the result of iteration of the given block over all elements of the matrix. …\n"],["collect","Vector","Vector.html#method-i-collect","()","<p>Like Array#collect.\n"],["collect!","Matrix","Matrix.html#method-i-collect-21","(which = :all)","<p>Invokes the given block for each element of matrix, replacing the element with the value returned by …\n"],["collect!","Vector","Vector.html#method-i-collect-21","(&block)","<p>Like Array#collect!\n"],["collect2","Vector","Vector.html#method-i-collect2","(v)","<p>Collects (as in Enumerable#collect) over the elements of this vector and <code>v</code> in conjunction.\n"],["column","Matrix","Matrix.html#method-i-column","(j)","<p>Returns column vector number <code>j</code> of the matrix as a Vector (starting at 0 like an array).  When a block …\n"],["column_vector","Matrix","Matrix.html#method-c-column_vector","(column)","<p>Creates a single-column matrix where the values of that column are as given in <code>column</code>.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">column_vector</span>([<span class=\"ruby-value\">4</span>,<span class=\"ruby-value\">5</span>,<span class=\"ruby-value\">6</span>]) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["column_vectors","Matrix","Matrix.html#method-i-column_vectors","()","<p>Returns an array of the column vectors of the matrix.  See Vector.\n"],["columns","Matrix","Matrix.html#method-c-columns","(columns)","<p>Creates a matrix using <code>columns</code> as an array of column vectors.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">columns</span>([[<span class=\"ruby-value\">25</span>, <span class=\"ruby-value\">93</span>], [<span class=\"ruby-value\">-1</span>, <span class=\"ruby-value\">66</span>]])\n<span class=\"ruby-comment\">#  ...</span>\n</pre>\n"],["combine","Matrix","Matrix.html#method-c-combine","(*matrices)","<p>Create a matrix by combining matrices entrywise, using the given block\n\n<pre>x = Matrix[[6, 6], [4, 4]]\ny = ...</pre>\n"],["combine","Matrix","Matrix.html#method-i-combine","(*matrices, &block)","<p>Creates new matrix by combining with <em>other_matrices</em> entrywise, using the given block.\n\n<pre>x = Matrix[[6, 6], ...</pre>\n"],["component","Matrix","Matrix.html#method-i-component","(i, j)",""],["component","Vector","Vector.html#method-i-component","(i)",""],["conj","Matrix","Matrix.html#method-i-conj","()",""],["conjugate","Matrix","Matrix.html#method-i-conjugate","()","<p>Returns the conjugate of the matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-constant\">Complex</span>(<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">2</span>), <span class=\"ruby-constant\">Complex</span>(<span class=\"ruby-value\">0</span>,<span class=\"ruby-value\">1</span>), <span class=\"ruby-value\">0</span>], [<span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">2</span>, <span class=\"ruby-value\">3</span>]]\n<span class=\"ruby-comment\">#  =&gt; 1+2i   i ...</span>\n</pre>\n"],["covector","Vector","Vector.html#method-i-covector","()","<p>Creates a single-row matrix from this vector.\n"],["cross","Vector","Vector.html#method-i-cross","(*vs)",""],["cross_product","Vector","Vector.html#method-i-cross_product","(*vs)","<p>Returns the cross product of this vector with the others.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">0</span>, <span class=\"ruby-value\">0</span>].<span class=\"ruby-identifier\">cross_product</span> <span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">0</span>, <span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">0</span>] <span class=\"ruby-operator\">...</span>\n</pre>\n"],["d","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-d","()",""],["det","Matrix","Matrix.html#method-i-det","()",""],["det","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-det","()","<p>Returns the determinant of <code>A</code>, calculated efficiently from the factorization.\n"],["det_e","Matrix","Matrix.html#method-i-det_e","()",""],["determinant","Matrix","Matrix.html#method-i-determinant","()","<p>Returns the determinant of the matrix.\n<p>Beware that using Float values can yield erroneous results because …\n"],["determinant","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-determinant","()",""],["determinant_bareiss","Matrix","Matrix.html#method-i-determinant_bareiss","()","<p>Private. Use Matrix#determinant\n<p>Returns the determinant of the matrix, using Bareiss’ multistep integer-preserving …\n"],["determinant_e","Matrix","Matrix.html#method-i-determinant_e","()","<p>deprecated; use Matrix#determinant\n"],["diagonal","Matrix","Matrix.html#method-c-diagonal","(*values)","<p>Creates a matrix where the diagonal elements are composed of <code>values</code>.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">diagonal</span>(<span class=\"ruby-value\">9</span>, <span class=\"ruby-value\">5</span>, <span class=\"ruby-value\">-3</span>)\n<span class=\"ruby-comment\">#  =&gt;  ...</span>\n</pre>\n"],["diagonal?","Matrix","Matrix.html#method-i-diagonal-3F","()","<p>Returns <code>true</code> if this is a diagonal matrix. Raises an error if matrix is not square.\n"],["diagonalize","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-diagonalize","()","<p>Symmetric tridiagonal QL algorithm.\n"],["dot","Vector","Vector.html#method-i-dot","(v)",""],["each","Matrix","Matrix.html#method-i-each","(which = :all)","<p>Yields all elements of the matrix, starting with those of the first row, or returns an Enumerator if …\n"],["each","Vector","Vector.html#method-i-each","(&block)","<p>Iterate over the elements of this vector\n"],["each2","Vector","Vector.html#method-i-each2","(v)","<p>Iterate over the elements of this vector and <code>v</code> in conjunction.\n"],["each_with_index","Matrix","Matrix.html#method-i-each_with_index","(which = :all)","<p>Same as #each, but the row index and column index in addition to the element\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[ [<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">2</span>], [<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">4</span>] ].<span class=\"ruby-identifier\">each_with_index</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["eigen","Matrix","Matrix.html#method-i-eigen","()",""],["eigensystem","Matrix","Matrix.html#method-i-eigensystem","()","<p>Returns the Eigensystem of the matrix; see <code>EigenvalueDecomposition</code>.\n\n<pre>m = Matrix[[1, 2], [3, 4]]\nv, d, v_inv ...</pre>\n"],["eigenvalue_matrix","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvalue_matrix","()","<p>Returns the block diagonal eigenvalue matrix <code>D</code>\n"],["eigenvalues","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvalues","()","<p>Returns the eigenvalues in an array\n"],["eigenvector_matrix","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvector_matrix","()","<p>Returns the eigenvector matrix <code>V</code>\n"],["eigenvector_matrix_inv","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvector_matrix_inv","()","<p>Returns the inverse of the eigenvector matrix <code>V</code>\n"],["eigenvectors","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvectors","()","<p>Returns an array of the eigenvectors\n"],["element","Matrix","Matrix.html#method-i-element","(i, j)",""],["element","Vector","Vector.html#method-i-element","(i)",""],["elements","Vector","Vector.html#method-c-elements","(array, copy = true)","<p>Creates a vector from an Array.  The optional second argument specifies whether the array itself or a …\n"],["elements_to_f","Matrix","Matrix.html#method-i-elements_to_f","()","<p>Deprecated.\n<p>Use <code>map(&amp;:to_f)</code>\n"],["elements_to_f","Vector","Vector.html#method-i-elements_to_f","()",""],["elements_to_i","Matrix","Matrix.html#method-i-elements_to_i","()","<p>Deprecated.\n<p>Use <code>map(&amp;:to_i)</code>\n"],["elements_to_i","Vector","Vector.html#method-i-elements_to_i","()",""],["elements_to_r","Matrix","Matrix.html#method-i-elements_to_r","()","<p>Deprecated.\n<p>Use <code>map(&amp;:to_r)</code>\n"],["elements_to_r","Vector","Vector.html#method-i-elements_to_r","()",""],["empty","Matrix","Matrix.html#method-c-empty","(row_count = 0, column_count = 0)","<p>Creates a empty matrix of <code>row_count</code> x <code>column_count</code>. At least one of <code>row_count</code> or <code>column_count</code> must be …\n"],["empty?","Matrix","Matrix.html#method-i-empty-3F","()","<p>Returns <code>true</code> if this is an empty matrix, i.e. if the number of rows or the number of columns is 0.\n"],["entrywise_product","Matrix","Matrix.html#method-i-entrywise_product","(m)",""],["eql?","Matrix","Matrix.html#method-i-eql-3F","(other)",""],["eql?","Vector","Vector.html#method-i-eql-3F","(other)",""],["find_index","Matrix","Matrix.html#method-i-find_index","(*args)",""],["first_minor","Matrix","Matrix.html#method-i-first_minor","(row, column)","<p>Returns the submatrix obtained by deleting the specified row and column.\n\n<pre>Matrix.diagonal(9, 5, -3, 4).first_minor(1, ...</pre>\n"],["freeze","Matrix","Matrix.html#method-i-freeze","()",""],["freeze","Vector","Vector.html#method-i-freeze","()","<p>Makes the matrix frozen and Ractor-shareable\n"],["hadamard_product","Matrix","Matrix.html#method-i-hadamard_product","(m)","<p>Hadamard product\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">2</span>], [<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">4</span>]].<span class=\"ruby-identifier\">hadamard_product</span>(<span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">2</span>], [<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">2</span>]])\n<span class=\"ruby-comment\">#  =&gt; 1  4</span>\n<span class=\"ruby-comment\">#     9  8</span>\n</pre>\n"],["hash","Matrix","Matrix.html#method-i-hash","()","<p>Returns a hash-code for the matrix.\n"],["hash","Vector","Vector.html#method-i-hash","()","<p>Returns a hash-code for the vector.\n"],["hermitian?","Matrix","Matrix.html#method-i-hermitian-3F","()","<p>Returns <code>true</code> if this is an hermitian matrix. Raises an error if matrix is not square.\n"],["hessenberg_to_real_schur","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-hessenberg_to_real_schur","()","<p>Nonsymmetric reduction from Hessenberg to real Schur form.\n"],["hstack","Matrix","Matrix.html#method-c-hstack","(x, *matrices)","<p>Create a matrix by stacking matrices horizontally\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">x</span> = <span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">2</span>], [<span class=\"ruby-value\">3</span>, <span class=\"ruby-value\">4</span>]]\n<span class=\"ruby-identifier\">y</span> = <span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">5</span>, <span class=\"ruby-value\">6</span>], [<span class=\"ruby-value\">7</span>, <span class=\"ruby-value\">8</span>]] <span class=\"ruby-operator\">...</span>\n</pre>\n"],["hstack","Matrix","Matrix.html#method-i-hstack","(*matrices)","<p>Returns a new matrix resulting by stacking horizontally the receiver with the given matrices\n\n<pre>x = Matrix[[1, ...</pre>\n"],["identity","Matrix","Matrix.html#method-c-identity","(n)","<p>Creates an <code>n</code> by <code>n</code> identity matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">identity</span>(<span class=\"ruby-value\">2</span>)\n<span class=\"ruby-comment\">#  =&gt; 1 0</span>\n<span class=\"ruby-comment\">#     0 1</span>\n</pre>\n"],["imag","Matrix","Matrix.html#method-i-imag","()",""],["imaginary","Matrix","Matrix.html#method-i-imaginary","()","<p>Returns the imaginary part of the matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-constant\">Complex</span>(<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">2</span>), <span class=\"ruby-constant\">Complex</span>(<span class=\"ruby-value\">0</span>,<span class=\"ruby-value\">1</span>), <span class=\"ruby-value\">0</span>], [<span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">2</span>, <span class=\"ruby-value\">3</span>]]\n<span class=\"ruby-comment\">#  =&gt; 1+2i ...</span>\n</pre>\n"],["independent?","Vector","Vector.html#method-c-independent-3F","(*vs)","<p>Returns whether all of vectors are linearly independent.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Vector</span>.<span class=\"ruby-identifier\">independent?</span>(<span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span>], <span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">0</span>,<span class=\"ruby-value\">1</span>]) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["independent?","Vector","Vector.html#method-i-independent-3F","(*vs)","<p>Returns whether all of vectors are linearly independent.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span>].<span class=\"ruby-identifier\">independent?</span>(<span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">0</span>,<span class=\"ruby-value\">1</span>])\n<span class=\"ruby-comment\"># =&gt; true ...</span>\n</pre>\n"],["index","Matrix","Matrix.html#method-i-index","(*args)","<p>The index method is specialized to return the index as [row, column] It also accepts an optional <code>selector</code> …\n"],["initialize_copy","Matrix","Matrix.html#method-i-initialize_copy","(m)","<p>Called for dup &amp; clone.\n"],["initialize_copy","Vector","Vector.html#method-i-initialize_copy","(v)","<p>Called for dup &amp; clone.\n"],["inner_product","Vector","Vector.html#method-i-inner_product","(v)","<p>Returns the inner product of this vector with the other.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">4</span>,<span class=\"ruby-value\">7</span>].<span class=\"ruby-identifier\">inner_product</span> <span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">10</span>,<span class=\"ruby-value\">1</span>] <span class=\"ruby-comment\"># =&gt; 47</span>\n</pre>\n"],["inspect","Matrix","Matrix.html#method-i-inspect","()","<p>Overrides Object#inspect\n"],["inspect","Vector","Vector.html#method-i-inspect","()","<p>Overrides Object#inspect\n"],["inv","Matrix","Matrix.html#method-i-inv","()",""],["inverse","Matrix","Matrix.html#method-i-inverse","()","<p>Returns the inverse of the matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">-1</span>, <span class=\"ruby-value\">-1</span>], [<span class=\"ruby-value\">0</span>, <span class=\"ruby-value\">-1</span>]].<span class=\"ruby-identifier\">inverse</span>\n<span class=\"ruby-comment\">#  =&gt; -1  1</span>\n<span class=\"ruby-comment\">#      0 -1</span>\n</pre>\n"],["l","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-l","()",""],["laplace_expansion","Matrix","Matrix.html#method-i-laplace_expansion","(row: nil, column: nil)","<p>Returns the Laplace expansion along given row or column.\n\n<pre>Matrix[[7,6], [3,9]].laplace_expansion(column: ...</pre>\n"],["lower_triangular?","Matrix","Matrix.html#method-i-lower_triangular-3F","()","<p>Returns <code>true</code> if this is a lower triangular matrix.\n"],["lup","Matrix","Matrix.html#method-i-lup","()","<p>Returns the LUP decomposition of the matrix; see <code>LUPDecomposition</code>.\n\n<pre>a = Matrix[[1, 2], [3, 4]]\nl, u, p ...</pre>\n"],["lup_decomposition","Matrix","Matrix.html#method-i-lup_decomposition","()",""],["magnitude","Vector","Vector.html#method-i-magnitude","()","<p>Returns the modulus (Pythagorean distance) of the vector.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">5</span>,<span class=\"ruby-value\">8</span>,<span class=\"ruby-value\">2</span>].<span class=\"ruby-identifier\">r</span> <span class=\"ruby-comment\"># =&gt; 9.643650761</span>\n</pre>\n"],["map","Matrix","Matrix.html#method-i-map","(which = :all)",""],["map","Vector","Vector.html#method-i-map","()",""],["map!","Matrix","Matrix.html#method-i-map-21","(which = :all)",""],["map!","Vector","Vector.html#method-i-map-21","(&block)",""],["map2","Vector","Vector.html#method-i-map2","(v)","<p>Like Vector#collect2, but returns a Vector instead of an Array.\n"],["minor","Matrix","Matrix.html#method-i-minor","(*param)","<p>Returns a section of the matrix.  The parameters are either:\n<p>start_row, nrows, start_col, ncols; OR\n<p>row_range …\n"],["new","ExceptionForMatrix::ErrDimensionMismatch","ExceptionForMatrix/ErrDimensionMismatch.html#method-c-new","(val = nil)",""],["new","ExceptionForMatrix::ErrNotRegular","ExceptionForMatrix/ErrNotRegular.html#method-c-new","(val = nil)",""],["new","ExceptionForMatrix::ErrOperationNotDefined","ExceptionForMatrix/ErrOperationNotDefined.html#method-c-new","(vals)",""],["new","ExceptionForMatrix::ErrOperationNotImplemented","ExceptionForMatrix/ErrOperationNotImplemented.html#method-c-new","(vals)",""],["new","Matrix","Matrix.html#method-c-new","(rows, column_count = rows[0].size)","<p>Matrix.new is private; use ::rows, ::columns, ::[], etc… to create.\n"],["new","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-c-new","(a)","<p>Constructs the eigenvalue decomposition for a square matrix <code>A</code>\n"],["new","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-c-new","(a)",""],["new","Vector","Vector.html#method-c-new","(array)","<p>Vector.new is private; use Vector[] or Vector.elements to create.\n"],["norm","Vector","Vector.html#method-i-norm","()",""],["normal?","Matrix","Matrix.html#method-i-normal-3F","()","<p>Returns <code>true</code> if this is a normal matrix. Raises an error if matrix is not square.\n"],["normalize","Vector","Vector.html#method-i-normalize","()","<p>Returns a new vector with the same direction but with norm 1.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">v</span> = <span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">5</span>,<span class=\"ruby-value\">8</span>,<span class=\"ruby-value\">2</span>].<span class=\"ruby-identifier\">normalize</span>\n<span class=\"ruby-comment\"># =&gt; Vector[0.5184758473652127, ...</span>\n</pre>\n"],["orthogonal?","Matrix","Matrix.html#method-i-orthogonal-3F","()","<p>Returns <code>true</code> if this is an orthogonal matrix Raises an error if matrix is not square.\n"],["p","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-p","()","<p>Returns the permutation matrix <code>P</code>\n"],["permutation?","Matrix","Matrix.html#method-i-permutation-3F","()","<p>Returns <code>true</code> if this is a permutation matrix Raises an error if matrix is not square.\n"],["power_int","Matrix","Matrix.html#method-i-power_int","(exp)",""],["r","Vector","Vector.html#method-i-r","()",""],["rank","Matrix","Matrix.html#method-i-rank","()","<p>Returns the rank of the matrix. Beware that using Float values can yield erroneous results because of …\n"],["rank_e","Matrix","Matrix.html#method-i-rank_e","()","<p>deprecated; use Matrix#rank\n"],["real","Matrix","Matrix.html#method-i-real","()","<p>Returns the real part of the matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-constant\">Complex</span>(<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">2</span>), <span class=\"ruby-constant\">Complex</span>(<span class=\"ruby-value\">0</span>,<span class=\"ruby-value\">1</span>), <span class=\"ruby-value\">0</span>], [<span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">2</span>, <span class=\"ruby-value\">3</span>]]\n<span class=\"ruby-comment\">#  =&gt; 1+2i  i ...</span>\n</pre>\n"],["real?","Matrix","Matrix.html#method-i-real-3F","()","<p>Returns <code>true</code> if all entries of the matrix are real.\n"],["rect","Matrix","Matrix.html#method-i-rect","()","<p>Returns an array containing matrices corresponding to the real and imaginary parts of the matrix\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">m</span>.<span class=\"ruby-identifier\">rect</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["rectangular","Matrix","Matrix.html#method-i-rectangular","()",""],["reduce_to_hessenberg","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-reduce_to_hessenberg","()","<p>Nonsymmetric reduction to Hessenberg form.\n"],["regular?","Matrix","Matrix.html#method-i-regular-3F","()","<p>Returns <code>true</code> if this is a regular (i.e. non-singular) matrix.\n"],["rotate_entries","Matrix","Matrix.html#method-i-rotate_entries","(rotation = :clockwise)","<p>Returns a new matrix with rotated elements. The argument specifies the rotation (defaults to ‘:clockwise`): …\n"],["round","Matrix","Matrix.html#method-i-round","(ndigits=0)","<p>Returns a matrix with entries rounded to the given precision (see Float#round)\n"],["round","Vector","Vector.html#method-i-round","(ndigits=0)","<p>Returns a vector with entries rounded to the given precision (see Float#round)\n"],["row","Matrix","Matrix.html#method-i-row","(i)","<p>Returns row vector number <code>i</code> of the matrix as a Vector (starting at 0 like an array).  When a block is …\n"],["row_count","Matrix","Matrix.html#method-i-row_count","()","<p>Returns the number of rows.\n"],["row_size","Matrix","Matrix.html#method-i-row_size","()",""],["row_vector","Matrix","Matrix.html#method-c-row_vector","(row)","<p>Creates a single-row matrix where the values of that row are as given in <code>row</code>.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">row_vector</span>([<span class=\"ruby-value\">4</span>,<span class=\"ruby-value\">5</span>,<span class=\"ruby-value\">6</span>]) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["row_vectors","Matrix","Matrix.html#method-i-row_vectors","()","<p>Returns an array of the row vectors of the matrix.  See Vector.\n"],["rows","Matrix","Matrix.html#method-c-rows","(rows, copy = true)","<p>Creates a matrix where <code>rows</code> is an array of arrays, each of which is a row of the matrix.  If the optional …\n"],["scalar","Matrix","Matrix.html#method-c-scalar","(n, value)","<p>Creates an <code>n</code> by <code>n</code> diagonal matrix where each diagonal element is <code>value</code>.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">scalar</span>(<span class=\"ruby-value\">2</span>, <span class=\"ruby-value\">5</span>)\n<span class=\"ruby-comment\">#  =&gt; 5 0 ...</span>\n</pre>\n"],["set_col_range","Matrix","Matrix.html#method-i-set_col_range","(row, col_range, value)",""],["set_column_vector","Matrix","Matrix.html#method-i-set_column_vector","(row_range, col, value)",""],["set_component","Matrix","Matrix.html#method-i-set_component","(i, j, v)",""],["set_component","Vector","Vector.html#method-i-set_component","(i, v)",""],["set_element","Matrix","Matrix.html#method-i-set_element","(i, j, v)",""],["set_element","Vector","Vector.html#method-i-set_element","(i, v)",""],["set_range","Vector","Vector.html#method-i-set_range","(range, value)",""],["set_row_and_col_range","Matrix","Matrix.html#method-i-set_row_and_col_range","(row_range, col_range, value)",""],["set_row_range","Matrix","Matrix.html#method-i-set_row_range","(row_range, col, value)",""],["set_value","Matrix","Matrix.html#method-i-set_value","(row, col, value)",""],["set_value","Vector","Vector.html#method-i-set_value","(index, value)",""],["singular?","Matrix","Matrix.html#method-i-singular-3F","()","<p>Returns <code>true</code> if this is a singular matrix.\n"],["singular?","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-singular-3F","()","<p>Returns <code>true</code> if <code>U</code>, and hence <code>A</code>, is singular.\n"],["size","Vector","Vector.html#method-i-size","()","<p>Returns the number of elements in the vector.\n"],["skew_symmetric?","Matrix","Matrix.html#method-i-skew_symmetric-3F","()",""],["solve","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-solve","(b)","<p>Returns <code>m</code> so that <code>A*m = b</code>, or equivalently so that <code>L*U*m = P*b</code> <code>b</code> can be a Matrix or a Vector\n"],["square?","Matrix","Matrix.html#method-i-square-3F","()","<p>Returns <code>true</code> if this is a square matrix.\n"],["symmetric?","Matrix","Matrix.html#method-i-symmetric-3F","()","<p>Returns <code>true</code> if this is a symmetric matrix. Raises an error if matrix is not square.\n"],["t","Matrix","Matrix.html#method-i-t","()",""],["to_a","Matrix","Matrix.html#method-i-to_a","()","<p>Returns an array of arrays that describe the rows of the matrix.\n"],["to_a","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-to_a","()",""],["to_a","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-to_a","()",""],["to_a","Vector","Vector.html#method-i-to_a","()","<p>Returns the elements of the vector in an array.\n"],["to_ary","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-to_ary","()","<p>Returns [eigenvector_matrix, eigenvalue_matrix, eigenvector_matrix_inv]\n"],["to_ary","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-to_ary","()","<p>Returns <code>L</code>, <code>U</code>, <code>P</code> in an array\n"],["to_matrix","Matrix","Matrix.html#method-i-to_matrix","()","<p>Explicit conversion to a Matrix. Returns self\n"],["to_matrix","Vector","Vector.html#method-i-to_matrix","()","<p>Return a single-column matrix from this vector\n"],["to_s","Matrix","Matrix.html#method-i-to_s","()","<p>Overrides Object#to_s\n"],["to_s","Vector","Vector.html#method-i-to_s","()","<p>Overrides Object#to_s\n"],["tr","Matrix","Matrix.html#method-i-tr","()",""],["trace","Matrix","Matrix.html#method-i-trace","()","<p>Returns the trace (sum of diagonal elements) of the matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">7</span>,<span class=\"ruby-value\">6</span>], [<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">9</span>]].<span class=\"ruby-identifier\">trace</span>\n<span class=\"ruby-comment\">#  =&gt; 16</span>\n</pre>\n"],["transpose","Matrix","Matrix.html#method-i-transpose","()","<p>Returns the transpose of the matrix.\n\n<pre>Matrix[[1,2], [3,4], [5,6]]\n#  =&gt; 1 2\n#     3 4\n#     5 6\nMatrix[[1,2], ...</pre>\n"],["tridiagonalize","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-tridiagonalize","()","<p>Symmetric Householder reduction to tridiagonal form.\n"],["u","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-u","()","<p>Returns the upper triangular factor <code>U</code>\n"],["unit","Matrix","Matrix.html#method-c-unit","(n)",""],["unitary?","Matrix","Matrix.html#method-i-unitary-3F","()","<p>Returns <code>true</code> if this is a unitary matrix Raises an error if matrix is not square.\n"],["upper_triangular?","Matrix","Matrix.html#method-i-upper_triangular-3F","()","<p>Returns <code>true</code> if this is an upper triangular matrix.\n"],["v","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-v","()",""],["v_inv","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-v_inv","()",""],["vstack","Matrix","Matrix.html#method-c-vstack","(x, *matrices)","<p>Create a matrix by stacking matrices vertically\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">x</span> = <span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">2</span>], [<span class=\"ruby-value\">3</span>, <span class=\"ruby-value\">4</span>]]\n<span class=\"ruby-identifier\">y</span> = <span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">5</span>, <span class=\"ruby-value\">6</span>], [<span class=\"ruby-value\">7</span>, <span class=\"ruby-value\">8</span>]] <span class=\"ruby-operator\">...</span>\n</pre>\n"],["vstack","Matrix","Matrix.html#method-i-vstack","(*matrices)","<p>Returns a new matrix resulting by stacking vertically the receiver with the given matrices\n\n<pre>x = Matrix[[1, ...</pre>\n"],["zero","Matrix","Matrix.html#method-c-zero","(row_count, column_count = row_count)","<p>Creates a zero matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">zero</span>(<span class=\"ruby-value\">2</span>)\n<span class=\"ruby-comment\">#  =&gt; 0 0</span>\n<span class=\"ruby-comment\">#     0 0</span>\n</pre>\n"],["zero","Vector","Vector.html#method-c-zero","(size)","<p>Return a zero vector.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Vector</span>.<span class=\"ruby-identifier\">zero</span>(<span class=\"ruby-value\">3</span>) <span class=\"ruby-comment\"># =&gt; Vector[0, 0, 0]</span>\n</pre>\n"],["zero?","Matrix","Matrix.html#method-i-zero-3F","()","<p>Returns <code>true</code> if this is a matrix with only zero elements\n"],["zero?","Vector","Vector.html#method-i-zero-3F","()","<p>Returns whether all elements are zero.\n"]]}}