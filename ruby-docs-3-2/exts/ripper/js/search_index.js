var search_data = {"index":{"searchIndex":["dsl","object","ripper","filter","lexer","elem","state","&()","==()","[]()","[]()","add_event()","allbits?()","anybits?()","check_arity()","column()","column()","compile_error()","const_missing()","debug_output()","debug_output=()","dedent_string()","dedent_string()","encoding()","end_seen?()","error?()","filename()","filename()","generate_eventids1()","generate_eventids2_table()","grammar()","inspect()","lex()","lex_state_name()","lineno()","lineno()","main()","method_missing()","new()","new()","new()","new()","new()","new_var()","nobits?()","on_default()","opt_event()","parse()","parse()","parse()","prelude()","pretty_print()","pretty_print()","read_ids1()","read_ids1_with_locations()","read_ids2()","sexp()","sexp_raw()","slice()","state()","state()","strip_locations()","to_a()","to_s()","token()","tokenize()","usage()","usercode()","warn()","warning()","yydebug()","yydebug=()","|()"],"longSearchIndex":["dsl","object","ripper","ripper::filter","ripper::lexer","ripper::lexer::elem","ripper::lexer::state","ripper::lexer::state#&()","ripper::lexer::state#==()","ripper::lexer::elem#[]()","ripper::lexer::state#[]()","object#add_event()","ripper::lexer::state#allbits?()","ripper::lexer::state#anybits?()","object#check_arity()","ripper#column()","ripper::filter#column()","ripper#compile_error()","object::const_missing()","ripper#debug_output()","ripper#debug_output=()","ripper::dedent_string()","ripper#dedent_string()","ripper#encoding()","ripper#end_seen?()","ripper#error?()","ripper#filename()","ripper::filter#filename()","object#generate_eventids1()","object#generate_eventids2_table()","object#grammar()","ripper::lexer::elem#inspect()","ripper::lex()","ripper::lex_state_name()","ripper#lineno()","ripper::filter#lineno()","object#main()","object#method_missing()","dsl::new()","ripper::new()","ripper::filter::new()","ripper::lexer::elem::new()","ripper::lexer::state::new()","object#new_var()","ripper::lexer::state#nobits?()","ripper::filter#on_default()","object#opt_event()","ripper::parse()","ripper#parse()","ripper::filter#parse()","object#prelude()","ripper::lexer::elem#pretty_print()","ripper::lexer::state#pretty_print()","object#read_ids1()","object#read_ids1_with_locations()","object#read_ids2()","ripper::sexp()","ripper::sexp_raw()","ripper::slice()","ripper#state()","ripper::filter#state()","object#strip_locations()","ripper::lexer::elem#to_a()","ripper::lexer::elem#to_s()","ripper#token()","ripper::tokenize()","object#usage()","object#usercode()","ripper#warn()","ripper#warning()","ripper#yydebug()","ripper#yydebug=()","ripper::lexer::state#|()"],"info":[["DSL","","DSL.html","",""],["Object","","Object.html","",""],["Ripper","","Ripper.html","","<p>Ripper is a Ruby script parser.\n<p>You can get information from the parser with event-based style. Information …\n"],["Ripper::Filter","","Ripper/Filter.html","","<p>This class handles only scanner events, which are dispatched in the ‘right’ order (same with …\n"],["Ripper::Lexer","","Ripper/Lexer.html","",""],["Ripper::Lexer::Elem","","Ripper/Lexer/Elem.html","",""],["Ripper::Lexer::State","","Ripper/Lexer/State.html","",""],["&","Ripper::Lexer::State","Ripper/Lexer/State.html#method-i-26","(i)",""],["==","Ripper::Lexer::State","Ripper/Lexer/State.html#method-i-3D-3D","(i)",""],["[]","Ripper::Lexer::Elem","Ripper/Lexer/Elem.html#method-i-5B-5D","(index)",""],["[]","Ripper::Lexer::State","Ripper/Lexer/State.html#method-i-5B-5D","(index)",""],["add_event","Object","Object.html#method-i-add_event","(event, args, qundef_check = false)",""],["allbits?","Ripper::Lexer::State","Ripper/Lexer/State.html#method-i-allbits-3F","(i)",""],["anybits?","Ripper::Lexer::State","Ripper/Lexer/State.html#method-i-anybits-3F","(i)",""],["check_arity","Object","Object.html#method-i-check_arity","(h)",""],["column","Ripper","Ripper.html#method-i-column","()","<p>Return column number of current parsing line. This number starts from 0.\n"],["column","Ripper::Filter","Ripper/Filter.html#method-i-column","()","<p>The column number of the current token. This value starts from 0. This method is valid only in event …\n"],["compile_error","Ripper","Ripper.html#method-i-compile_error","(msg)","<p>This method is called when the parser found syntax error.\n"],["const_missing","Object","Object.html#method-c-const_missing","(name)",""],["debug_output","Ripper","Ripper.html#method-i-debug_output","()","<p>Get debug output.\n"],["debug_output=","Ripper","Ripper.html#method-i-debug_output-3D","(p1)","<p>Set debug output.\n"],["dedent_string","Ripper","Ripper.html#method-c-dedent_string","(p1, p2)","<p>USE OF RIPPER LIBRARY ONLY.\n<p>Strips up to <code>width</code> leading whitespaces from <code>input</code>, and returns the stripped …\n"],["dedent_string","Ripper","Ripper.html#method-i-dedent_string","(p1, p2)","<p>USE OF RIPPER LIBRARY ONLY.\n<p>Strips up to <code>width</code> leading whitespaces from <code>input</code>, and returns the stripped …\n"],["encoding","Ripper","Ripper.html#method-i-encoding","()","<p>Return encoding of the source.\n"],["end_seen?","Ripper","Ripper.html#method-i-end_seen-3F","()","<p>Return true if parsed source ended by +_<em>END</em>_+.\n"],["error?","Ripper","Ripper.html#method-i-error-3F","()","<p>Return true if parsed source has errors.\n"],["filename","Ripper","Ripper.html#method-i-filename","()","<p>Return current parsing filename.\n"],["filename","Ripper::Filter","Ripper/Filter.html#method-i-filename","()","<p>The file name of the input.\n"],["generate_eventids1","Object","Object.html#method-i-generate_eventids1","(ids)",""],["generate_eventids2_table","Object","Object.html#method-i-generate_eventids2_table","(ids)",""],["grammar","Object","Object.html#method-i-grammar","(f, out)",""],["inspect","Ripper::Lexer::Elem","Ripper/Lexer/Elem.html#method-i-inspect","()",""],["lex","Ripper","Ripper.html#method-c-lex","(src, filename = '-', lineno = 1, **kw)","<p>Tokenizes the Ruby program and returns an array of an array, which is formatted like <code>[[lineno, column],</code> …\n"],["lex_state_name","Ripper","Ripper.html#method-c-lex_state_name","(p1)","<p>Returns a string representation of lex_state.\n"],["lineno","Ripper","Ripper.html#method-i-lineno","()","<p>Return line number of current parsing line. This number starts from 1.\n"],["lineno","Ripper::Filter","Ripper/Filter.html#method-i-lineno","()","<p>The line number of the current token. This value starts from 1. This method is valid only in event handlers. …\n"],["main","Object","Object.html#method-i-main","()",""],["method_missing","Object","Object.html#method-i-method_missing","(event, *args)",""],["new","DSL","DSL.html#method-c-new","(code, options)",""],["new","Ripper","Ripper.html#method-c-new","(p1, p2 = v2, p3 = v3)","<p>Create a new Ripper object. <em>src</em> must be a String, an IO, or an Object which has #gets method.\n<p>This method …\n"],["new","Ripper::Filter","Ripper/Filter.html#method-c-new","(src, filename = '-', lineno = 1)","<p>Creates a new Ripper::Filter instance, passes parameters <code>src</code>, <code>filename</code>, and <code>lineno</code> to Ripper::Lexer.new …\n"],["new","Ripper::Lexer::Elem","Ripper/Lexer/Elem.html#method-c-new","(pos, event, tok, state, message = nil)",""],["new","Ripper::Lexer::State","Ripper/Lexer/State.html#method-c-new","(i)",""],["new_var","Object","Object.html#method-i-new_var","()",""],["nobits?","Ripper::Lexer::State","Ripper/Lexer/State.html#method-i-nobits-3F","(i)",""],["on_default","Ripper::Filter","Ripper/Filter.html#method-i-on_default","(event, token, data)","<p>This method is called when some event handler is undefined. <code>event</code> is :on_XXX, <code>token</code> is the scanned token, …\n"],["opt_event","Object","Object.html#method-i-opt_event","(event, default, addend)",""],["parse","Ripper","Ripper.html#method-c-parse","(src, filename = '(ripper)', lineno = 1)","<p>Parses the given Ruby program read from <code>src</code>. <code>src</code> must be a String or an IO or a object with a #gets method. …\n"],["parse","Ripper","Ripper.html#method-i-parse","()","<p>Start parsing and returns the value of the root action.\n"],["parse","Ripper::Filter","Ripper/Filter.html#method-i-parse","(init = nil)","<p>Starts the parser. <code>init</code> is a data accumulator and is passed to the next event handler (as of Enumerable#inject …\n"],["prelude","Object","Object.html#method-i-prelude","(f, out)",""],["pretty_print","Ripper::Lexer::Elem","Ripper/Lexer/Elem.html#method-i-pretty_print","(q)",""],["pretty_print","Ripper::Lexer::State","Ripper/Lexer/State.html#method-i-pretty_print","(q)",""],["read_ids1","Object","Object.html#method-i-read_ids1","(path)",""],["read_ids1_with_locations","Object","Object.html#method-i-read_ids1_with_locations","(path)",""],["read_ids2","Object","Object.html#method-i-read_ids2","(path)",""],["sexp","Ripper","Ripper.html#method-c-sexp","(src, filename = '-', lineno = 1, raise_errors: false)","<p>EXPERIMENTAL &mdash; Parses <code>src</code> and create S-exp tree. Returns more readable tree rather than Ripper.sexp_raw …\n"],["sexp_raw","Ripper","Ripper.html#method-c-sexp_raw","(src, filename = '-', lineno = 1, raise_errors: false)","<p>EXPERIMENTAL &mdash; Parses <code>src</code> and create S-exp tree. This method is mainly for developer use. The <code>filename</code> …\n"],["slice","Ripper","Ripper.html#method-c-slice","(src, pattern, n = 0)","<p>EXPERIMENTAL &mdash; Parses <code>src</code> and return a string which was matched to <code>pattern</code>. <code>pattern</code> should be described …\n"],["state","Ripper","Ripper.html#method-i-state","()","<p>Return scanner state of current token.\n"],["state","Ripper::Filter","Ripper/Filter.html#method-i-state","()","<p>The scanner’s state of the current token. This value is the bitwise OR of zero or more of the <code>Ripper::EXPR_*</code> …\n"],["strip_locations","Object","Object.html#method-i-strip_locations","(h)",""],["to_a","Ripper::Lexer::Elem","Ripper/Lexer/Elem.html#method-i-to_a","()",""],["to_s","Ripper::Lexer::Elem","Ripper/Lexer/Elem.html#method-i-to_s","()",""],["token","Ripper","Ripper.html#method-i-token","()","<p>Return the current token string.\n"],["tokenize","Ripper","Ripper.html#method-c-tokenize","(src, filename = '-', lineno = 1, **kw)","<p>Tokenizes the Ruby program and returns an array of strings. The <code>filename</code> and <code>lineno</code> arguments are mostly …\n"],["usage","Object","Object.html#method-i-usage","(msg)",""],["usercode","Object","Object.html#method-i-usercode","(f, out)",""],["warn","Ripper","Ripper.html#method-i-warn","(fmt, *args)","<p>This method is called when weak warning is produced by the parser. <code>fmt</code> and <code>args</code> is printf style.\n"],["warning","Ripper","Ripper.html#method-i-warning","(fmt, *args)","<p>This method is called when strong warning is produced by the parser. <code>fmt</code> and <code>args</code> is printf style.\n"],["yydebug","Ripper","Ripper.html#method-i-yydebug","()","<p>Get yydebug.\n"],["yydebug=","Ripper","Ripper.html#method-i-yydebug-3D","(p1)","<p>Set yydebug.\n"],["|","Ripper::Lexer::State","Ripper/Lexer/State.html#method-i-7C","(i)",""]]}}